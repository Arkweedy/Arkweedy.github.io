<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ICPC 2023 杭州区域赛</title>
    <url>/2024/11/07/%E9%A2%98%E8%A7%A3/Regional%20Contest/ICPC2023_HangZhou_Regional_Contest/</url>
    <content><![CDATA[<h1 id="gym入口"><a
href="https://codeforces.comu/gym/104976">Gym入口</a></h1>
<h1 id="preface">Preface</h1>
<p>和<a
href="">小木虫</a>一起vp的，赛后补了队友独立写出来的题以及赛时尝试开的两道金牌题。
题解顺序： M-J-D-H-G-F-B</p>
<h1 id="m.-v-diagram"><a
href="https://codeforces.com/gym/104976/problem/M">M. V-Diagram</a></h1>
<p>签到题，题意大概是给定一个V型数组，取一个最大平均值的子V型数组。<br />
赛时WA了两次后才得到了正确思路。<br />
首先，V型数组至少有3个元素，而且要求是子数组，那么可以去掉的只有两端不与极小值直接相邻的部分。<br />
可以考虑贪心，如果我们要去掉一端的一部分，那么去掉那端全部不与极小值相邻的元素一定是最优的。(因为我们去掉一端时，是先去掉大的再去掉小的，那么要去掉一定是全部去掉)<br />
而贪心一个一个去是不可取的，因为可能去掉一个元素会让平均值减小，但是去掉那一整段又可以让平均值变大。<br />
而去掉两端一定是劣的(这样把较大的值全全去掉了)<br />
故答案为不去，去掉左端可以去掉的部分，去掉右端可以去掉的部分三者平均值中取最大值。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    deque&lt;ll&gt;d;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            p = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ll pre = <span class="number">0</span>, suf = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pcnt = <span class="number">0</span>, scnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pre += a[i];</span><br><span class="line">        pcnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = p + <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        suf += a[i];</span><br><span class="line">        scnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ans = sum / (<span class="type">double</span>)(n);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, (sum - pre) / (<span class="type">double</span>)(n - pcnt));</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, (sum - suf) / (<span class="type">double</span>)(n - scnt));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.14llf\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="j.-mysterious-tree"><a
href="https://codeforces.com/gym/104976/problem/J">J. Mysterious
Tree</a></h1>
<p>交互题<br />
题意：给一颗树,是链或者是菊花。使用<span
class="math inline">\(\left\lceil\frac{n}{2}\right\rceil +
3\)</span>次询问是否存在一条边<span
class="math inline">\(\{u,v\}\)</span>来确定。<strong>交互是自适应的</strong>。<br />
无论是链还是菊花，都只有<span
class="math inline">\(n-1\)</span>条边，是稀疏图,而问不出一条存在的边，我们便完全无法确定图的类型。所以考虑如何在有限的询问次数中去问出特定类型图的其中一条边。<br />
如果是链，那么是无法通过某种特定的询问序列去问出某条存在的边的。(也就是说，对任何询问序列(询问是不能自适应的，因为问出一条边存在前，得到的都是不存在的返回)，都可以构造出一条链不被问到任意一条边)。<br />
而如果是一颗菊花，我们考虑询问<span
class="math inline">\(\{v_1,v_2\},\{v_3,v_4\}...\)</span>而遍历到每一个顶点。如果这棵树是一颗菊花，那么它存在一个顶点与其他所有顶点之间有边。当询问到这个顶点时，就可以问出一条边。这样一个询问序列，最多消耗<span
class="math inline">\(\left\lceil\frac{n}{2}\right\rceil\)</span>次询问。<br />
问出一条边<span
class="math inline">\(\{u,v\}\)</span>后，我们仍需用剩下3次询问去确定这到底是链还是菊花。如果是菊花，取其他顶点<span
class="math inline">\(w\)</span>,分别询问<span
class="math inline">\(u,v\)</span>是否与<span
class="math inline">\(w\)</span>有边。<br />
1. 均没有边，那么是一条链。<br />
2. 其一有边，不妨设是<span
class="math inline">\(\{u,w\}\)</span>，这时菊花和链还是均有可能。那我们再用最后一次机会询问<span
class="math inline">\(u\)</span>和其他顶点是否有边。<br />
2.1. 如果无边，那么不可能是菊花，是链<br />
2.2. 如果有边，一定是菊花。</p>
<p>code: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> T,n,res;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> z=<span class="built_in">rnd</span>()%n<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">while</span>(z==x||z==y)</span><br><span class="line">		z=<span class="built_in">rnd</span>()%n<span class="number">+1</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;res;</span><br><span class="line">	<span class="keyword">if</span>(!res)<span class="built_in">swap</span>(x,y);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;res;</span><br><span class="line">	<span class="keyword">if</span>(!res)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;! 1&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> o=<span class="built_in">rnd</span>()%n<span class="number">+1</span>;</span><br><span class="line">	<span class="keyword">while</span>(o==x||o==y||o==z)</span><br><span class="line">		o=<span class="built_in">rnd</span>()%n<span class="number">+1</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;o&lt;&lt;endl;</span><br><span class="line">	cin&gt;&gt;res;</span><br><span class="line">	<span class="keyword">if</span>(res)cout&lt;&lt;<span class="string">&quot;! 2&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;! 1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">			cin&gt;&gt;res;</span><br><span class="line">			<span class="keyword">if</span>(res)&#123;</span><br><span class="line">				<span class="built_in">work</span>(i,i<span class="number">+1</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">			cin&gt;&gt;res;</span><br><span class="line">			<span class="keyword">if</span>(res)&#123;</span><br><span class="line">				<span class="built_in">work</span>(i,i<span class="number">+1</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;? &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;res;</span><br><span class="line">		<span class="keyword">if</span>(res)&#123;</span><br><span class="line">			<span class="built_in">work</span>(n,n<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;! 1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="d.-operator-precedence"><a
href="https://codeforces.com/gym/104976/problem/D">D. Operator
Precedence</a></h1>
<p>妙妙构建题加上智慧的样例<br />
(vp的时候真红温了)<br />
实际上完全不用管样例，为了让乘式的值尽可能小，不妨将中间全部控制为1，只留最后一部分为变量，解二元一次方程(控制解为整数)即可构造出合法序列。<br />
最后构造出的序列是形如<span
class="math inline">\(-1,2,-1,2,...,n-2,1\)</span>的数列。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1 -3 -3 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1 2 &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;n<span class="number">-2</span>&lt;&lt;<span class="string">&quot; 1 &quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="h.-sugar-sweet-ii"><a
href="https://codeforces.com/gym/104976/problem/H">H. Sugar Sweet
II</a></h1>
<p>节点之间的依赖关系组成一颗外向基环树(或森林)(关于外向树，内向树和基环树可以了解一下)。外向基环树节点的k级祖先是确定的。<br />
对于节点<span class="math inline">\(v\)</span>，如果<span
class="math inline">\(a_v &lt;
b_v\)</span>那么这个节点一定可以获得加成，如果<span
class="math inline">\(a_v &gt;= b_v +
w_v\)</span>,那么一定不能获得加成，如果介于中间，则可否获得加成取决于节点选取的顺序。我们可以先预处理一遍所有节点，把一定可以获得加成的节点概率<span
class="math inline">\(p_v\)</span>设成1，一定不能获得加成的节点概率设成0。这些节点均为已确定的节点。<br />
对于中间状态的节点，我们推导它获得加成的概率。<br />
每个中间节点的状态，取决于其父节点的状态，往前递推，取决于其一系列祖先节点的状态。而想要获得加成，只能是其父节点<span
class="math inline">\(f_1\)</span>已获得加成后，再选择该节点。由数学归纳法，如果其最小的确定状态祖先为k级祖先(存在环上的例外情况)，那么<span
class="math inline">\(f_1,f_2,...f_{k-1}\)</span>都获得加成，该节点才能获得加成。若<span
class="math inline">\(p_{f_k} = 0\)</span>,这些情况都不可能发生，即<span
class="math inline">\(p_{f_0} = p_{f_1} = ... = p_{f_{k-1}} =
0\)</span>。若<span class="math inline">\(p_{f_k} =
1\)</span>,则满足条件的事件发生顺序只有<span
class="math inline">\(\{f_{k-1},f_{k-2},...,f_1,f_0\}\)</span>,由排列数的公式，得到<span
class="math inline">\(p_{f_0} = \frac{1}{A_k^k} =
\frac{1}{k!}\)</span>.此外，有一种特殊情况，即某个圈中没有任何已确定节点，那么由于任何节点被选取后其父节点仍处于加成状态，其概率应为0，从而这个环内所有点概率均为0。<br />
实现上，我们从所有已确定的点处执行一遍dfs，dfs遇到已确定的点就返回，否则按照规则计算该点处的概率。剩下的未访问的点即为特殊情况中的点，将其概率设为0即可。<br />
关于计算k的阶乘倒数的算法，或许我的计算方法有可以优化的地方。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;g, vector&lt;ll&gt;&amp; p, <span class="type">int</span> s, ll t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[s] == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : g[s]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="number">-1</span>) &#123;</span><br><span class="line">                p[j] = <span class="built_in">inv</span>(t) % mod * p[s] % mod;</span><br><span class="line">                <span class="built_in">dfs</span>(g, p, j, t + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">a</span>(n + <span class="number">1</span>), <span class="built_in">b</span>(n + <span class="number">1</span>), <span class="built_in">w</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">p</span>(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        g[b[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[b[i]]) &#123;</span><br><span class="line">            p[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= a[b[i]] + w[b[i]]) &#123;</span><br><span class="line">            p[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(g, p, i, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] == <span class="number">-1</span>)</span><br><span class="line">            p[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ll ans = (a[i] + (w[i] * p[i] % mod)) % mod;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="g.-snake-move"><a
href="https://codeforces.com/gym/104976/problem/G">G. Snake
Move</a></h1>
<p>贪吃蛇，给出初始的蛇头蛇身位置和地图状态，每步操作可以上/下/左/右移动一格或者缩短蛇身一格。询问到达所有位置的最小步数，以平方和的形式输出。<br />
如果不是蛇身节点，那么最小步数就是蛇头到这个点的操作距离(这可能不等于路径距离)，如果是从蛇尾数起的第k个节点(蛇尾是第一个)，那么最小步数是操作距离和len-k取min.<br />
可以做到<span
class="math inline">\(O(mn)\)</span>，具体实现是使用bfs。使用一个二维数组来模拟队列。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span><span class="number">+4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m,k,f[<span class="number">3004</span>][<span class="number">3004</span>];</span><br><span class="line"><span class="type">char</span> c[<span class="number">3004</span>][<span class="number">3004</span>];<span class="type">int</span> v[<span class="number">3004</span>][<span class="number">3004</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100004</span>],b[<span class="number">100004</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">3004</span>][<span class="number">3004</span>];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;V[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;b[i]),v[a[i]][b[i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,c[i]<span class="number">+1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="keyword">if</span>(c[i][j]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			v[i][j]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">	ans[a[<span class="number">1</span>]][b[<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">	V[<span class="number">0</span>].<span class="built_in">emplace_back</span>(a[<span class="number">1</span>],b[<span class="number">1</span>]);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span>[p,q]:V[i])<span class="keyword">if</span>(ans[p][q]==i)&#123;</span><br><span class="line">			ret+=(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)i*i;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++)&#123;</span><br><span class="line">				<span class="type">int</span> P=p+dx[d],Q=q+dy[d];</span><br><span class="line">				<span class="keyword">if</span>(!P||!Q||P&gt;n||Q&gt;m||v[P][Q]&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">				<span class="type">int</span> D=i<span class="number">+1</span>;</span><br><span class="line">				<span class="keyword">if</span>(v[P][Q]&gt;<span class="number">0</span>&amp;&amp;k-v[P][Q]&gt;=D)D=k-v[P][Q]<span class="number">+1</span>;</span><br><span class="line">				<span class="keyword">if</span>(D&lt;ans[P][Q])</span><br><span class="line">					ans[P][Q]=D,V[D].<span class="built_in">emplace_back</span>(P,Q);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="f.-top-cluster"><a
href="https://codeforces.com/gym/104976/problem/F">F. Top
Cluster</a></h1>
<p>大概题意：给一个带边权(路径长)和点权的树，保证点权两两不同。多次询问一个节点<span
class="math inline">\(v\)</span>的k-邻域内所有点权集合的mex。需要做到每次询问在<span
class="math inline">\(\log n\)</span>的时间内解决才不会tle。<br />
大概是第一次做这种糅合了一些树上算法知识的题。<br />
需要的算法： Euler序求LCA，二分，树的直径及其性质。</p>
<p>分析：<br />
求出k邻域内的点集显然是<span
class="math inline">\(O(n)\)</span>的，如果我们暴力求解k-邻域内的点，再求解mex显然是不行的。<br />
计算两点间的距离是可以做到<span class="math inline">\(O(n\log
n)\)</span>预处理<span
class="math inline">\(O(1)\)</span>查询的，使用的是通过Euler序将求解LCA转化成求解RMQ。而我们求解某个点<span
class="math inline">\(v\)</span>的k-邻域mex，即是找出一个具有如下性质的边界值<span
class="math inline">\(r\)</span>：<br />
1. 点权小于<span
class="math inline">\(r\)</span>的点均存在，且全部位于<span
class="math inline">\(v\)</span>的k-邻域内。<br />
2. 点权为<span class="math inline">\(r\)</span>的点不存在，或者位于<span
class="math inline">\(v\)</span>的k-邻域外。</p>
<p>接着推进上面所述思路的可行性。<br />
我们可以观察到边界值<span
class="math inline">\(r\)</span>是满足二分答案的条件的：对于小于<span
class="math inline">\(r\)</span>的值均满足第一条性质，大于r的值均不满足第一条性质。所以我们如果能够在<span
class="math inline">\(O(1)\)</span>时间内进行一次判断，就可以使用二分法将单次询问的时间复杂度降到<span
class="math inline">\(O(\log n)\)</span>。<br />
如何判断一个点集内的点是否全在k-邻域内呢？首先，因为使用二分法，我们会按点权排序。所以我们check的点集是固定的，即按点权排序后的前缀和。所以点集我们可以预先处理出来。<br />
判断树上点集是否在范围内，可以转化为求点集内的点到给定点的最大距离。所以我们求解这些点集的直径，而树上任意点到这些点集内的点的最大距离一定等于到直径端点的最大距离。所以我们从check一个点集内的所有点变成判check直径的端点。求解前缀和集合的直径可以<span
class="math inline">\(O(n)\)</span>解决。<br />
于是，我们得出了这个<span class="math inline">\(O(n\log
n)\)</span>的解法。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;w;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;idx;</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, ll&gt;&gt;&gt;g;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;dfn;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;dval;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;elr;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;eidx;</span><br><span class="line">vector&lt;ll&gt;dis;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;lca;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;dia;</span><br><span class="line"><span class="type">int</span> dfncnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_elr</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dfn[r] != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dfn[r] = dfncnt++;</span><br><span class="line">        dval[dfn[r]] = r;</span><br><span class="line">        elr.<span class="built_in">push_back</span>(dfn[r]);</span><br><span class="line">        eidx[r] = elr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [p, d] : g[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p != fa) &#123;</span><br><span class="line">                dis[p] = dis[r] + d;</span><br><span class="line">                <span class="built_in">get_elr</span>(p, r);</span><br><span class="line">                elr.<span class="built_in">push_back</span>(dfn[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> iu = eidx[u], iv = eidx[v];</span><br><span class="line">    <span class="keyword">if</span> (iu &gt; iv)</span><br><span class="line">        <span class="built_in">swap</span>(iu, iv);</span><br><span class="line">    <span class="type">int</span> len = iv - iu + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">floor</span>(<span class="built_in">log2</span>(len));</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">min</span>(lca[iu][k], lca[iv - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">return</span> dval[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dist</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[u] + dis[v] - <span class="number">2</span> * dis[<span class="built_in">Lca</span>(u, v)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;res = other;</span><br><span class="line">    ll len = <span class="built_in">dist</span>(other.first, other.second);</span><br><span class="line">    ll len1 = <span class="built_in">dist</span>(a.first, other.first), len2 = <span class="built_in">dist</span>(a.first, other.second);</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len) &#123;</span><br><span class="line">        res = &#123; a.first,other.first &#125;;</span><br><span class="line">        len = len1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len2 &gt; len) &#123;</span><br><span class="line">        res = &#123; a.first,other.second &#125;;</span><br><span class="line">        len = len2;</span><br><span class="line">    &#125;</span><br><span class="line">    a = res;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">floor</span>(<span class="built_in">log2</span>(n * <span class="number">2</span> - <span class="number">1</span>));</span><br><span class="line">    w.<span class="built_in">resize</span>(n);</span><br><span class="line">    dfn.<span class="built_in">resize</span>(n);</span><br><span class="line">    dval.<span class="built_in">resize</span>(n<span class="number">+1</span>);</span><br><span class="line">    eidx.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="comment">//elr.resize(n * 2 + 1);</span></span><br><span class="line">    g.<span class="built_in">resize</span>(n);</span><br><span class="line">    dis.<span class="built_in">resize</span>(n);</span><br><span class="line">    lca.<span class="built_in">resize</span>(n * <span class="number">2</span> - <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len + <span class="number">1</span>, inf));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">        idx[w[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//auto a = w;</span></span><br><span class="line">    <span class="built_in">sort</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, d;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; d;</span><br><span class="line">        u--;</span><br><span class="line">        v--;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(&#123; v,d &#125;);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(&#123; u,d &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_elr</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> elrlen = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elrlen; i++) &#123;</span><br><span class="line">        lca[i][<span class="number">0</span>] = elr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt; elrlen; j++) &#123;</span><br><span class="line">            lca[j][i] = <span class="built_in">min</span>(lca[j][i - <span class="number">1</span>], lca[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort as w</span></span><br><span class="line">    dia.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dia[i] = &#123; idx[w[i]],idx[w[i]] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">merge</span>(dia[i], dia[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rlim = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w[i] != i) &#123;</span><br><span class="line">            rlim = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll x, k;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line">        x--;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">-1</span>, r = rlim;</span><br><span class="line">        <span class="keyword">while</span> (r - l &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> midi = <span class="built_in">lower_bound</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), mid) - w.<span class="built_in">begin</span>();</span><br><span class="line">            ll d = <span class="built_in">max</span>(<span class="built_in">dist</span>(x, dia[midi].first), <span class="built_in">dist</span>(x, dia[midi].second));</span><br><span class="line">            <span class="keyword">if</span> (d &lt;= k) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="b.-festival-decorating"><a
href="https://codeforces.com/gym/104976/problem/B">B. Festival
Decorating</a></h1>
<p>这题有着蜜汁check，考虑误差范围好像可以用多项式科技解决(但是我不会QWQ)。不过学习了这题利用bitset精确求解的解法。bitset,太强大！<br />
由于答案的优先级是下标(并非位置)较小的优先，我们可以按下标顺序枚举该点可以贡献的答案，已有答案的距离不再枚举。可行的枚举位置需要两步操作得出：<br />
1. 去除同颜色的灯<br />
2. 去除已获得答案的距离对应位置的灯</p>
<p>剩余有灯的位置均为可贡献答案的位置。<br />
这显然是一个<span
class="math inline">\(O(n^2)\)</span>的做法，其中我们枚举出来可以贡献答案的位置以及记录答案操作有<span
class="math inline">\(n\)</span>的数量级，但是找到这些位置的操作数
是<span
class="math inline">\(n^2\)</span>级别的。这时我们就可以利用我们的bitset,降低没有关联其他操作的常数，达到<span
class="math inline">\(O(\frac{n^2}{\omega})\)</span>的时间复杂度。<br />
具体做法：<br />
我们用一个二维vector存不同颜色的点，用bitset <span
class="math inline">\(mp\)</span>存数轴的状态(有灯为1，无灯为0),并且再用一个bitset
<span
class="math inline">\(getans\)</span>存以及获得了答案的距离的状态(未获得答案为0).<br />
对于操作1，这是关联了遍历某个特定颜色点集的操作，bitset无法降低时间复杂度。但是我们可以使用Big
Small(根号分治)来降低时间复杂度。对于出现次数大于<span
class="math inline">\(\sqrt
N\)</span>的颜色，我们预处理出初始序列取出掉这些点得到的序列，时间复杂度为<span
class="math inline">\(O(N)\)</span>，但是这种操作不会大于<span
class="math inline">\(\sqrt N\)</span>次。对于出现次数小于<span
class="math inline">\(\sqrt
N\)</span>的颜色，我们每次遇到时再执行操作1即可，每次执行的时间复杂度不超过<span
class="math inline">\(O(\sqrt N)\)</span>,最多操作<span
class="math inline">\(n\)</span>次。通过根号分治，我们将操作1的总时间复杂度降到<span
class="math inline">\(O(n\sqrt N)\)</span>级别。<br />
对于操作2，这是只使用了bitset的操作，时间复杂度被bitset优化。我们获取目前考虑的点的位置<span
class="math inline">\(x\)</span>，可枚举的位置用bitset表示即为<span
class="math inline">\(mp &gt;&gt;x \&amp; \sim
getans\)</span>。这部分的时间复杂度为<span
class="math inline">\(O(\frac{n^2}{\omega})\)</span><br />
做完预处理操作后，遍历bitset，找到为1的位置填入答案即可。G++里bitset有_Find_first()和pos._Find_next(p)函数，比较好写。为什么MSVC没有这些函数
:(<br />
把对应两种操作的算法组合起来，即可得到使用bitset的正解。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">250001</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sq = <span class="built_in">sqrt</span>(N);</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">cl</span>(n);</span><br><span class="line">    <span class="comment">//vector&lt;int&gt;mp(N);</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(N);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">g</span>(N);</span><br><span class="line">    bitset&lt;N&gt;s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        a[i] = x;</span><br><span class="line">        cl[i] = c;</span><br><span class="line">        <span class="comment">//mp[x] = c;</span></span><br><span class="line">        s[x] = <span class="literal">true</span>;</span><br><span class="line">        g[c].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;bitset&lt;N&gt;&gt;msk;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">idx</span>(N,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i].<span class="built_in">size</span>() &gt;= sq)&#123;</span><br><span class="line">            bitset&lt;N&gt;st;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[i])</span><br><span class="line">                st.<span class="built_in">set</span>(j);</span><br><span class="line">            idx[i] = msk.<span class="built_in">size</span>();</span><br><span class="line">            msk.<span class="built_in">push_back</span>(s&amp;(~st));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bitset&lt;N&gt;getans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        bitset&lt;N&gt;pos;</span><br><span class="line">        <span class="keyword">if</span>(idx[cl[i]] == <span class="number">-1</span>)&#123;</span><br><span class="line">            pos = s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[cl[i]])</span><br><span class="line">                pos[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pos = msk[idx[cl[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        pos &gt;&gt;= a[i];</span><br><span class="line">        pos &amp;= ~getans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p = pos._Find_first();p != pos.<span class="built_in">size</span>();p = pos._Find_next(p) )&#123;</span><br><span class="line">            ans[p] = i + <span class="number">1</span>;</span><br><span class="line">            getans.<span class="built_in">set</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">        cin&gt;&gt;d;</span><br><span class="line">        cout&lt;&lt;ans[d]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>(ps: 难产了两周的补题题解终于生出来了)</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Regional Contest</category>
      </categories>
  </entry>
  <entry>
    <title>CF Round974 div3</title>
    <url>/2024/10/21/%E9%A2%98%E8%A7%A3/Codeforces/Contest/cf_round974_div3/</url>
    <content><![CDATA[<h1 id="d-robert-hood-and-mrs-hood"><a
href="https://codeforces.com/contest/2014/problem/D">D Robert Hood and
Mrs Hood</a></h1>
<p>赛时对l,r分别进行了排序,来测算是否有事件进入，实际上这是没有必要的。</p>
<p>可以直接用一个桶来记录。buc[l]--,buc[r+1]--即可。</p>
<p>不难，时间复杂度为<span class="math inline">\(O(n)\)</span></p>
<h1 id="e---rendez-vous-de-marian-et-robin"><a
href="https://codeforces.com/contest/2014/problem/E">E - Rendez-vous de
Marian et Robin</a></h1>
<p>赛时魔改dijkstra没有改出来(实际上应该也很难改出来)
赛后了解到分层图，直接开悟
做法是对每个节点，建图建一个有马节点，一个无马节点，有horse的节点就让无马节点向有马节点连边。对于给出的边，有马图和无马图同步建图。最后跑一遍Dijkstra就行。</p>
<h1 id="f---sheriffs-defense"><a
href="https://codeforces.com/contest/2014/problem/F">F - Sheriff's
Defense</a></h1>
<p>由于给出的是树形结构，可以当作一颗有根树。
和图最大的不同点是这样的树上问题可以做到无后效性(考虑树上dfs，不会有背向边或者横叉边)，换言之就是可以dp/dfs
(虽然我一开始想试试贪心，但是最后也没有试出来，而且时间复杂度上是不如dp的，实现上也比dp难，所以说dp好啊)
由于一个节点有两种状态，每个节点的贡献仅由这个节点和相邻节点决定。
于是我们考虑有根树上的状态转移： 两个相邻节点都取的话，总贡献减去<span
class="math inline">\(2c\)</span> 取<span
class="math inline">\(S_u\)</span>为<span
class="math inline">\(u\)</span>节点的子节点集合，<span
class="math inline">\(dp[u]\)</span>为子树的贡献</p>
<p><span class="math inline">\(dp[u][0] = \sum_{v\in S_u}
\max(dp[v][0],dp[v][1])\)</span> <span class="math inline">\(dp[u][1] =
\sum_{v\in S_u} \max(dp[v][0],dp[v][1]-2c)\)</span></p>
<p>实现用dfs实现即可。</p>
<p>核心代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp1用a[i]初始化</span></span><br><span class="line"><span class="built_in">dfs</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[p].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[p][i] != fa) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(g, a, dp0, dp1, g[p][i], p, c);</span><br><span class="line">            dp0[p] += <span class="built_in">max</span>(dp0[g[p][i]], dp1[g[p][i]]);</span><br><span class="line">            dp1[p] += <span class="built_in">max</span>(dp0[g[p][i]], dp1[g[p][i]] - c * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>Contest</category>
      </categories>
  </entry>
  <entry>
    <title>CF Round 972 div2</title>
    <url>/2024/10/21/%E9%A2%98%E8%A7%A3/Codeforces/Contest/cf_round972_div2/</url>
    <content><![CDATA[<h1 id="c.-lazy-narek"><a
href="https://codeforces.com/contest/2005/problem/C">C. Lazy
Narek</a></h1>
<p>dp即可； <strong>不过一定要好好读题才行！！</strong>
就是读题读假了和不仔细，才导致vp赛时没有调出来。
这个dp的优化(或者是自然而然的处理)：数组开1维5个位置即可，不需要对m轮全部开一个位置，否则会tle。状态转移时记得滚动，不要在原数组上面改，否则会出问题(可能跑出来同一层选了两次的结果)</p>
<h1 id="d.-alter-the-gcd"><a
href="https://codeforces.com/contest/2005/problem/D">D. Alter the
GCD</a></h1>
<h2 id="analysis">analysis</h2>
<p>前缀和后缀和gcd自然不用多说。逐一枚举<span
class="math inline">\(\{l，r\}\)</span>即使每次枚举求值是<span
class="math inline">\(O(1)\)</span>也会tle。所以要寻求更好的方法求解。</p>
<p>由于一个数的质因子最多只有<span class="math inline">\(\log
n\)</span>个，考虑gcd prefix是单调非升的，那么有如下性质： 只有最多<span
class="math inline">\(\log n\)</span>个位置 <span
class="math inline">\(i\)</span> 使 $ prefix[i] &gt; prefix[i+1] $
,其余均为 <span class="math inline">\(prefix[i] = prefix[i+1]\)</span>
对suffix gcd类似。 那么实际上，绝大多数前后缀gcd是相等的。 如果枚举<span
class="math inline">\(\{l，r\}\)</span>是对于<span
class="math inline">\(l\)</span>或<span
class="math inline">\(r\)</span>都是<span
class="math inline">\(O(n)\)</span>，组合起来是<span
class="math inline">\(O(n^2)\)</span>的的话，我们枚举单个变量的前缀/后缀值可以把这个枚举降到一个<span
class="math inline">\(O(\log n)\)</span>的时间复杂度
基于这样的观察，我们有不同的思路求解：</p>
<h2 id="solve1-分治">solve1 分治</h2>
<p>我们枚举l，r代表的前后缀值的话，那么中间这部分怎么加进来呢?如何防止l&gt;r呢
(毕竟不同的值都转化成了gcd value) 我们考虑设定一个枚举范围 $ [l,r],mid =
(l+r)/2 $ ,枚举所有的<span class="math inline">\(l \le i \le
mid\)</span>和<span class="math inline">\((mid +1) \le j \le r\)</span>
这个时候所有跨 <span class="math inline">\(mid\)</span> 和 <span
class="math inline">\(mid+1\)</span>
间隙的值都被遍历到了，只剩两个子区间内部的没有被枚举。
于是我们递归地取求解 <span class="math inline">\([l,mid]\)</span> 和
<span class="math inline">\([mid+1,r]\)</span> ，而对于 <span
class="math inline">\(l = r\)</span> 的区间我们特别枚举答案 <span
class="math inline">\(\{l,r\}\)</span> (因为按照前面的规则的话 <span
class="math inline">\([l,r]\)</span>
是没有贡献对的，这样会漏，但是如果我们扩大 <span
class="math inline">\([l,r]\)</span>
的贡献对范围的话，导致重复贡献将难以处理。)
通过这样的递归，或者说是分治策略，我们按值枚举不重不漏地遍历了所有组合</p>
<p>那么如何通过<strong>按值枚举</strong>快速求出一个枚举范围 <span
class="math inline">\([l,r]\)</span> 所有的 <span
class="math inline">\(value(\{i,j\})\)</span> 呢
根据前面的分治策略，我们把三段gcd的复合转化成以mid为界的两段gcd的复合：(以数组a最终的gcd为例)
<span class="math display">\[p[i] =
\gcd(a_l,a_{l+1},...,a_{i-1},b_i,b_{i+1},...,b_{mid})\]</span> <span
class="math display">\[s[j] =
\gcd(b_{mid+1},b_{mid+2},...b_{j},a_{j+1},...,a_{r})\]</span> 由于对
<span class="math inline">\(a,b\)</span> 均要求出 <span
class="math inline">\(p[i] , s[j]\)</span> ,
我们用map&lt;pair&lt;int,int&gt;&gt;<span
class="math inline">\(pmp,smp\)</span>( <span
class="math inline">\(a,b\)</span> 相同位置的 <span
class="math inline">\(p[i],s[j]\)</span>
成一组存储，作为相异的键，值则为其数量)存储这样的 <span
class="math inline">\(p[i]\)</span> 的值和 <span
class="math inline">\(s[j]\)</span> 的值。
再利用一点点前缀和后缀和，我们便可以用<span
class="math inline">\(O(n)\)</span>的时间<strong>分别</strong>遍历<span
class="math inline">\(i,j\)</span>的所有取值 随后我们用两层循环遍历<span
class="math inline">\(pmp,smp\)</span>，将所有值的组合纳入答案
由前面的观察，这个部分的时间复杂度是<span
class="math inline">\(O(\log^2n)\)</span>
那么，我们处理每个区间的时间复杂度为： <span
class="math inline">\(O(n+\log^2n) = O(n)\)</span>
这是一个分治算法，那么整体复杂度为 <span class="math inline">\(O(n\log
n)\)</span>，足以通过本题。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>Contest</category>
      </categories>
  </entry>
  <entry>
    <title>CF Round981 div3</title>
    <url>/2024/10/25/%E9%A2%98%E8%A7%A3/Codeforces/Contest/cf_round981_div3/</url>
    <content><![CDATA[<h2 id="比赛入口"><a
href="https://codeforces.com/contest/2033">比赛入口</a></h2>
<h1 id="c"><a
href="https://codeforces.com/contest/2033/problem/C">C</a></h1>
<p>为了无后效性，我们对每一对可交换的数对，只计算交换对外层的影响(干扰度是否会减少)。而交换是相对的，所以对该层外层的操作与否也不会影响该层内层是否相对该层进行交换
<strong>(也就是说我们不需要真的去交换，只计数即可)</strong>。
所以做法即为贪心，我们如果发现交换可以使该层对外层的干扰数减少，那就使ans减去这个差值。任意次序遍历数组(比如说由外到内)均可，毕竟层与层之间没有影响。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>])</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">k</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> div = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>])</span><br><span class="line">            div++;</span><br><span class="line">        <span class="keyword">if</span> (a[n - i + <span class="number">1</span>] == a[n - i + <span class="number">2</span>])</span><br><span class="line">            div++;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[n - i + <span class="number">2</span>])</span><br><span class="line">            div--;</span><br><span class="line">        <span class="keyword">if</span> (a[n - i + <span class="number">1</span>] == a[i - <span class="number">1</span>])</span><br><span class="line">            div--;</span><br><span class="line">        sum -= <span class="built_in">max</span>(<span class="number">0</span>, div);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="d"><a
href="https://codeforces.com/contest/2033/problem/D">D</a></h1>
<p>我的做法是前缀和+线性dp
当前缀和在i，j两处相等时，说明[i+1,j]这一段的和为0。
我们用map记录每个前缀和点值出现的位置，若前面已出现，我们就将这一段纳入答案中。
用线性dp计算答案。 设状态<span
class="math inline">\(dp[i]\)</span>为在<span
class="math inline">\([1,i]\)</span>段的答案，那么如果<span
class="math inline">\(i\)</span>是某一段美丽线段<span
class="math inline">\([pre + 1,i]\)</span>的右端点(记<span
class="math inline">\(pre\)</span>为上一个相同的presum点值下标)，那么它可以是<span
class="math inline">\(pre\)</span>处的答案再加上1，或者等于<span
class="math inline">\(i-1\)</span>处的答案。 若<span
class="math inline">\(pre\)</span>存在，状态转移方程： <span
class="math display">\[dp[i+1] = \max(dp[i],dp[pre]+1)\]</span>
时间复杂度为<span class="math inline">\(O(n)\)</span><br />
此外，需要注意的是，不能漏掉下标为0处的presum(这代表着从1开始的美丽线段)，而map的初始化值为0，所以我们判断presum是否在前面出现过，需要对presum为0的情况特殊处理一下。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    map&lt;ll, ll&gt;mp;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">dp</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mp[a[i]] != <span class="number">0</span> || a[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = dp[mp[a[i]]] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        mp[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = dp[n];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="e"><a
href="https://codeforces.com/contest/2033/problem/E">E</a></h1>
<p>感觉是比较典的题，类似的有：<a
href="https://ac.nowcoder.com/acm/contest/81599/C">牛客多校2024第4场
Sort4</a></p>
<p>首先我们明确一个<span class="math inline">\(1 -n\)</span>的排列<span
class="math inline">\(p\)</span>，由<span
class="math inline">\(i\)</span>向<span
class="math inline">\(p[i]\)</span>连边构成的有向图的结构：<br />
1. 这个图只由若干个不相交的环构成(自环也算环)<br />
2. 图中不存在链或者指向环的链(原因：<span
class="math inline">\(p[i]\)</span>的值不同)</p>
<p>再看题意，实际上就是需要我们通过若干次交换操作使这个图只由大小为1或者2的环组成。
我们观察swap操作,可以发现(这里推荐仔细思考一下)：<br />
1. swap不同环上的点，将两个环合并成一个环。<br />
2. swap相同环上的点，将一个环分裂成两个环。(可以想想是怎么分裂的)</p>
<p>所以最优操作即为：对每个点数<span class="math inline">\(n &gt;
2\)</span>的环，我们都不断地分裂出点数为2的环直到符合题意为止，操作数<span
class="math inline">\(k = \left \lfloor\frac{n-1}{2}
\right\rfloor\)</span></p>
<p>时间复杂度为<span class="math inline">\(O(n)\)</span><br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; vs, <span class="type">int</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vs[p])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        vs[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(a, vs, a[p]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">vs</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">dfs</span>(a,vs, i);</span><br><span class="line">        ans += (t - <span class="number">1</span>) / <span class="number">2</span>;k</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="f"><a
href="https://codeforces.com/contest/2033/problem/F">F</a></h1>
<p>找规律题。具体证明实际上没有太懂。<br />
打表可以发现n-th <span class="math inline">\(g(k) =
n*g(k)\)</span><br />
又由于k的总和不会很大，<span
class="math inline">\(g(k)\)</span>的上界不好估计， 但是常数<span
class="math inline">\(t
=\max(g(k)/k)\)</span>应该不会过于大。所以对于每次询问，直接暴力解出第一个模<span
class="math inline">\(k\)</span>为0的位置，乘n即可 时间复杂度<span
class="math inline">\(O(t\cdot \sum k)\)</span><br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    ll f1 = <span class="number">1</span>, f2 = <span class="number">1</span>;</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; n % mod &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (f2 % k == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; (n % mod) * (cnt + <span class="number">2</span>) % mod &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="type">int</span> f = (f1 + f2) % k;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="g"><a
href="https://codeforces.com/contest/2033/problem/G">G</a></h1>
<p>树上问题，翻译一下题意，就是在一颗有根树上，多次询问一个节点v的k级祖先的子树上，距离v最远的节点的距离。</p>
<p>首先，求k级祖先，可以倍增法预处理(后面求lca也要用到这里的倍增)，<span
class="math inline">\(O(\log k)\)</span>查询。
那么，怎么求这颗子树上距离v最远的点的距离呢?</p>
<blockquote>
<p>引理1： 在一棵树上，从任意节点 y 开始进行一次
DFS，到达的距离其最远的节点 z 必为直径的一端</p>
</blockquote>
<p>那么就是说，树上任意点的距离最远点只能是树的直径端点。<br />
所以我们把问题转化成求所有子树的直径问题。而一个树的直径可以由它的子树的直径信息合并而来。</p>
<blockquote>
<p>引理2： 记<span class="math inline">\(diam(S)\)</span>为树上点集<span
class="math inline">\(S\)</span>的最远点对，有： <span
class="math display">\[ \rm{diam}(S_1\cup S_2) =
\rm{diam}(\rm{diam}(S_1) \cup \rm{diam}(S_2))\]</span></p>
</blockquote>
<p>于是我们遍历子树直径和该树直径的点集和的所有点对组合，找出最大路径长的点对，即为该树的直径。通过dfs自底向上合并即可。
其中求点对之间的路径长，我们使用公式 <span
class="math display">\[pathlen(u,v) = deep(u)+deep(v) -
2deep(\rm{lca}(u,v))\]</span>即可
求lca则利用前面预处理的倍增信息来求。<br />
时间复杂度：<span class="math inline">\(O(n)\)</span></p>
<p>code： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;g;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;fa;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;dep;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;dia;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[p][<span class="number">0</span>] = f;</span><br><span class="line">    dep[p] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : g[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s != f) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(s, p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v])</span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="type">int</span> div = dep[u] - dep[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; div != <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (div &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">            div -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v)</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">19</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[u][j] != fa[v][j]) &#123;</span><br><span class="line">                u = fa[u][j];</span><br><span class="line">                v = fa[v][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathlen</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep[u] + dep[v] - <span class="number">2</span> * dep[<span class="built_in">lca</span>(u, v)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;p, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;res;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pathlen</span>(p.first, p.second) &gt;= <span class="built_in">pathlen</span>(s.first, s.second)) &#123;</span><br><span class="line">        res = p;</span><br><span class="line">        len = <span class="built_in">pathlen</span>(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res = s;</span><br><span class="line">        len = <span class="built_in">pathlen</span>(s.first, s.second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pathlen</span>(p.first, s.first) &gt; len) &#123;</span><br><span class="line">        res = &#123; p.first,s.first &#125;;</span><br><span class="line">        len = <span class="built_in">pathlen</span>(p.first, s.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pathlen</span>(p.first, s.second) &gt; len) &#123;</span><br><span class="line">        res = &#123; p.first,s.second &#125;;</span><br><span class="line">        len = <span class="built_in">pathlen</span>(p.first, s.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pathlen</span>(p.second, s.first) &gt; len) &#123;</span><br><span class="line">        res = &#123; p.second,s.first &#125;;</span><br><span class="line">        len = <span class="built_in">pathlen</span>(p.second, s.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pathlen</span>(p.second, s.second) &gt; len) &#123;</span><br><span class="line">        res = &#123; p.second,s.second &#125;;</span><br><span class="line">        len = <span class="built_in">pathlen</span>(p.second, s.second);</span><br><span class="line">    &#125;</span><br><span class="line">    p = res;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : g[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s != f) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(s, p);</span><br><span class="line">            <span class="built_in">merge</span>(dia[p], dia[s]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    g.<span class="built_in">clear</span>();</span><br><span class="line">    fa.<span class="built_in">clear</span>();</span><br><span class="line">    dep.<span class="built_in">clear</span>();</span><br><span class="line">    dia.<span class="built_in">clear</span>();</span><br><span class="line">    g.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">    fa.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">30</span>));</span><br><span class="line">    dep.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dia.<span class="built_in">resize</span>(n + <span class="number">1</span>, &#123; <span class="number">0</span>,<span class="number">0</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            fa[j][i] = fa[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dia[i] = &#123; i,i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> u, k;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; k;</span><br><span class="line">        <span class="type">int</span> v = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; k != <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                u = fa[u][i];</span><br><span class="line">                k -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(<span class="built_in">pathlen</span>(v, dia[u].first), <span class="built_in">pathlen</span>(v, dia[u].second));</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><em>ps:因为直径是<strong>dia</strong>meter,所以封面就用Dia了</em></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>Contest</category>
      </categories>
  </entry>
  <entry>
    <title>CF Round982 div2</title>
    <url>/2024/11/02/%E9%A2%98%E8%A7%A3/Codeforces/Contest/cf_round982_div2/</url>
    <content><![CDATA[<h2 id="比赛入口"><a
href="https://codeforces.com/contest/2027">比赛入口</a></h2>
<h1 id="c"><a
href="https://codeforces.com/contest/2027/problem/C">C</a></h1>
<p>很简单，建图找一下最远点即可。<br />
不过因为点值比较离散，所以用map存邻接表(cf传统艺能卡ump，所以还是不用的好)。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(map&lt;ll, vector&lt;ll&gt;&gt;&amp; nxt, map&lt;ll, <span class="type">bool</span>&gt;&amp; vs, ll p, ll &amp;ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vs[p] = <span class="literal">true</span>;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : nxt[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vs[s] &amp;&amp; s != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(nxt, vs, s,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;ll, vector&lt;ll&gt;&gt;nxt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nxt[a[i] + i <span class="number">-1</span>].<span class="built_in">push_back</span>(a[i] + i * <span class="number">2</span> - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;ll,<span class="type">bool</span>&gt;vs;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(nxt, vs, n, ans);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="d"><a
href="https://codeforces.com/contest/2027/problem/D2">D</a></h1>
<p>D1需要求解最少cost,D2还要求解最少cost的方案数。</p>
<h2 id="d1部分">D1部分</h2>
<p>首先分析题意，可以发现这是一个类似完全背包的问题。
所以我们可以背包dp解决。<br />
设定状态<span class="math inline">\(dp[i]\)</span>为取完<span
class="math inline">\(a_1 ... a_i\)</span>的最小费用。显然<span
class="math inline">\(dp\)</span>数组是单调非降的。对于每个下标<span
class="math inline">\(r\)</span>,设<span
class="math inline">\(l\)</span>是满足<span
class="math inline">\(\sum_{k=l}^{r} a[k] \leq
b[i]\)</span>的最小值，那么从<span
class="math inline">\(l-1\)</span>转移到<span
class="math inline">\(r\)</span>一定是最优的。于是有状态转移方程：<br />
<span class="math display">\[dp[r] = \min(dp[r],dp[l-1] +
m-i)\]</span><br />
于是问题转移到如何对于每一个<span
class="math inline">\(r\)</span>，在可以容忍的时间限下求出<span
class="math inline">\(l\)</span>。<br />
对此，我们可以使用双指针。想象一个队列,队尾为<span
class="math inline">\(l\)</span>，待加入元素为<span
class="math inline">\(a[r]\)</span><br />
1. 当剩余容积<span class="math inline">\(rem\)</span>大于等于物品<span
class="math inline">\(a[r]\)</span>的cost时，加入<span
class="math inline">\(a[r]\)</span>,此时的<span
class="math inline">\(\{l,r\}\)</span>即为一组合法的转移参数，于是执行转移。<br />
2. 当剩余容积<span class="math inline">\(rem\)</span>小于物品<span
class="math inline">\(a[r]\)</span>的cost时，我们弹出队尾元素，更新剩余容积。<br />
3. 特殊情况，当队列为空，且剩余容积<span
class="math inline">\(rem\)</span>小于物品<span
class="math inline">\(a[r]\)</span>的cost时，我们跳过这个物品。(操作即为l++,r++)<br />
这样，我们便可以<span
class="math inline">\(O(mn)\)</span>求得答案。<br />
可以预处理出所有的<span
class="math inline">\({l,r}\)</span>(官方题解),不过我就边求边dp了。<br />
code(D1 dp部分):<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;ll&gt;<span class="built_in">dp</span>(n + <span class="number">1</span>, inf);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rem = b[i];</span><br><span class="line">    <span class="keyword">for</span> (; r &lt;= n; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rem &gt;= a[r]) &#123;</span><br><span class="line">            rem -= a[r];</span><br><span class="line">            dp[r] = <span class="built_in">min</span>(dp[r], dp[l - <span class="number">1</span>] + m - i);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rem += a[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dp[n] == inf) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="d2部分">D2部分</h2>
<p>在求解D1的过程中，我们选取的是一定最优的<span
class="math inline">\(\{l,r\}\)</span>对进行转移,但实际上同等优的可以有很多对，而我们想要计数最优方案的话，就要转移所有同等优的(计数所有同等优的)才行。<br />
那么这实际上是一个从左区间到右点的转移，其他题解有用线段树进行区间转移优化的，不过实际上不需要，用双指针仍能做到，而且时间复杂度更优。<br />
前面所说"同等优的转移"很模糊，实际上，"同等优"的左区间即为<span
class="math inline">\(dp\)</span>值相同的区间，那么最优区间是和<span
class="math inline">\(dp[l]\)</span>值相同的区间，这个区间的内的任何点转移到<span
class="math inline">\(r\)</span>的值是一样的，所以我们可以把这个区间的转移变成一次转移，对计数的贡献则是最优区间内所有方案数相加。(想想这是为什么)<br />
设取完<span
class="math inline">\(1-i\)</span>d的最优方案数(最优转移路径数)为<span
class="math inline">\(path[i]\)</span>,最优区间右端点为<span
class="math inline">\(lr - 1\)</span><br />
有状态转移方程： <span class="math display">\[dp[r] = \min(dp[r],dp[l-1]
+ m-i)\]</span><br />
<span class="math display">\[\begin{align*}
    path[r] = \left\{
                \begin{array}{ll}
                  \sum_{i = l}^{lr}path[i] &amp; &amp;dp[r] &gt;
dp[l-1]+m-i\\
                  path[r] +\sum_{i = l}^{lr}path[i] &amp; &amp;dp[r] =
dp[l-1]+m-i\\
                  path[r] &amp; &amp;dp[r] &lt; dp[l-1]+m-i\\
                \end{array}
              \right.
\end{align*}\]</span></p>
<p>所以，我们需要在D1的基础上，对于求出所有<span
class="math inline">\(r\)</span>的最优转移区间<span
class="math inline">\(\{l,lr\}\)</span>,而这个也可以通过双指针做到(注意性质:当<span
class="math inline">\(r\)</span>增大时，<span
class="math inline">\(lr\)</span>同样是单调非降的！)。<br />
具体实现先思考一下会更好，以下是D2部分代码<br />
code: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">1</span>), <span class="built_in">b</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a.push_back(inf);</span></span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">dp</span>(n + <span class="number">1</span>, inf);</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">pa</span>(n + <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//path</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    pa[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>, lr = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rem = b[i];</span><br><span class="line">        ll cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt;= n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lr &lt; l) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rem &gt;= a[r]) &#123;</span><br><span class="line">                rem -= a[r];</span><br><span class="line">                <span class="keyword">while</span> (dp[lr<span class="number">-1</span>] == dp[l<span class="number">-1</span>] &amp;&amp; lr &lt;= r) &#123;<span class="comment">//lr == r : r-1 -&gt; r </span></span><br><span class="line">                    cnt = (cnt + pa[lr<span class="number">-1</span>]) % mod;</span><br><span class="line">                    lr++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[l<span class="number">-1</span>] + m - i &lt; dp[r]) &#123;</span><br><span class="line">                    dp[r] = dp[l<span class="number">-1</span>] + m - i;</span><br><span class="line">                    pa[r] = cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dp[l<span class="number">-1</span>] + m - i == dp[r]) &#123;</span><br><span class="line">                    pa[r] = (pa[r] + cnt) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    lr++;</span><br><span class="line">                    r++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    rem += a[l];</span><br><span class="line">                    cnt = (cnt + mod - pa[l - <span class="number">1</span>]) % mod;;</span><br><span class="line">                    l++;</span><br><span class="line">                    <span class="keyword">while</span> (lr &lt; l) &#123;</span><br><span class="line">                        cnt = (cnt + pa[lr - <span class="number">1</span>]) % mod;</span><br><span class="line">                        lr++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[n] == inf) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pa[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>Contest</category>
      </categories>
  </entry>
  <entry>
    <title>Week4 Training</title>
    <url>/2024/09/28/%E9%A2%98%E8%A7%A3/Codeforces/ProblemSet/week4/</url>
    <content><![CDATA[<h1 id="d.-the-omnipotent-monster-killer"><a
href="https://codeforces.com/contest/1988/problem/D">1988D. The
Omnipotent Monster Killer</a></h1>
<p>由于只有相邻节点之间才有影响，树形dp即可。
权值每次至少减半，故杀死所有怪物的轮数不会超过<span
class="math inline">\(\log n\)</span>轮，相邻节点删去的轮数不同。
在有根树上dp，<span
class="math inline">\(dp[i][j]\)</span>代表在节点i在第j轮删除时，节点<span
class="math inline">\(i\)</span>子树的最小贡献。 状态转移： <span
class="math inline">\(dp[i][j] = \sum_{v\in S_i}\min(dp[v][k]),k \neq
j\)</span></p>
<h1 id="e.-level-up"><a
href="https://codeforces.com/contest/1997/problem/E">1977E. Level
Up</a></h1>
<p>线段树+二分 第一次用自己写的线段树板子，爽捏。
对于每个位置，大于最小答案的每个k的取值都可以满足要求，故可以二分答案。check是计算答案为k时，前面的最小答案在1-k区间内的个数(即获得的exp)，然后按照题意判断即可。
<strong>一定要注意整型溢出的问题！！！</strong>
(因为在check的时候，使用了mid*a[i]与exp比较大小，而mid*a[i]是可能溢出的。)
(当然，可以直接比exp/mid 和a[i]) 核心代码： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SegTree&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(n)</span></span>;</span><br><span class="line">t.<span class="built_in">build</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> ng = <span class="number">0</span>, ok = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ok - ng &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (ng + ok) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> exp = t.<span class="built_in">qry</span>(<span class="number">1</span>, mid);</span><br><span class="line">        <span class="keyword">if</span> (exp / mid &gt;= a[i]) &#123;</span><br><span class="line">            ng = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ok = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[i] = ok;</span><br><span class="line">    t.<span class="built_in">upd</span>(ok, ok, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>ProblemSet</category>
      </categories>
  </entry>
  <entry>
    <title>Week3 Training</title>
    <url>/2024/09/21/%E9%A2%98%E8%A7%A3/Codeforces/ProblemSet/week3/</url>
    <content><![CDATA[<h1 id="h.-sakurakos-test"><a
href="https://codeforces.com/contest/2008/problem/H">2008H. Sakurako's
Test</a></h1>
<p>关键是前缀和和二分 以及对边界做一点特殊处理防止前缀数组越界
二分有说法的，要通过二分找到右边界(和中位数定义有关)
或许还可以改改代码，感觉自己写的有点怪</p>
<h1 id="g.-ultra-meow"><a
href="https://codeforces.com/contest/1992/problem/G">1992G.
Ultra-Meow</a></h1>
<p>看清这题的数据范围，对<span class="math inline">\(\sum
n^2\)</span>做了限制，所以单测<span
class="math inline">\(O(n^2)\)</span>的复杂度是没有问题的，不需要预处理所有答案然后<span
class="math inline">\(O(1)\)</span>查询。 做法是对于每个可能的<span
class="math inline">\(k = mex(S)\)</span>,对<span
class="math inline">\(k\)</span>分讨，算出每种k的贡献次数即可，复杂度<span
class="math inline">\(O(n^2)\)</span>。 需要一点点组合。
组合的板子在对负数的处理上好像有不兼容的的地方？
<strong>回头看看，改一下板子，这句话还在这里就表示没有修改板子以及搞清楚原因</strong></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>ProblemSet</category>
      </categories>
  </entry>
  <entry>
    <title>Week6 Training</title>
    <url>/2024/10/22/%E9%A2%98%E8%A7%A3/Codeforces/ProblemSet/week6/</url>
    <content><![CDATA[<h1 id="g.-milky-days"><a
href="https://codeforces.com/problemset/problem/2014/G">2014 G. Milky
Days</a></h1>
<p>实际上是一道模拟题，
我们定义关键天为牛奶数目可能会非因为喝掉而改变的那天。
利用一个deque去处理关键天时能否供给牛奶即可 则关键天为 <span
class="math inline">\(\min(最近牛奶过期天，下一个获得牛奶的天)\)</span>
我们一边求解答案一边算下一个关键天是哪个 假设关键天序列为<span
class="math inline">\(a_0,a_1,a_2,a_3...\)</span> 初始化<span
class="math inline">\(a_0 = 1\)</span>
由于一个关键天到下一个关键天前,牛奶只会被喝掉而不会过期、增加，那么我们就可以<span
class="math inline">\(O(1)\)</span>处理掉这一段了。 于是我们的算法是：
1. 算出下一个关键天<span class="math inline">\(a_{i+1}\)</span> 2.
处理区间<span class="math inline">\([a_i,a_{i+1}-1]\)</span> 3.
把关键天对milk数目的影响加入进去</p>
<p>显然，我们如上初始化之后，只需要一个简单的技巧：补一个足够大的关键天并让它对牛奶的影响为0，最后即可得到答案。</p>
<p>我们对每一段的处理是<span
class="math inline">\(O(1)\)</span>的，而总的关键天数不会超过<span
class="math inline">\(2n\)</span>(每一批的牛奶都过期了)，那么总的时间复杂度为<span
class="math inline">\(O(n)\)</span></p>
<details>
<summary>
Code:
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    deque&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;dq;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">d</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; d[i] &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">1145141919</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    ll mks = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nxt;</span><br><span class="line">        <span class="keyword">if</span> (dq.<span class="built_in">empty</span>())</span><br><span class="line">            nxt = d[p];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nxt = <span class="built_in">min</span>(dq.<span class="built_in">front</span>().second + k, d[p]);</span><br><span class="line"></span><br><span class="line">        ll need = (nxt - t) * (ll)m;</span><br><span class="line">        <span class="keyword">if</span> (mks &gt;= need) &#123;</span><br><span class="line">            mks -= need;</span><br><span class="line">            ans += nxt - t;</span><br><span class="line">            <span class="keyword">while</span> (need &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (need &gt;= dq.<span class="built_in">back</span>().first) &#123;</span><br><span class="line">                    need -= dq.<span class="built_in">back</span>().first;</span><br><span class="line">                    dq.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dq.<span class="built_in">back</span>().first -= need;</span><br><span class="line">                    need = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += mks / m;</span><br><span class="line">            mks = <span class="number">0</span>;</span><br><span class="line">            dq.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nxt == d[p]) &#123;</span><br><span class="line">            dq.<span class="built_in">push_back</span>(&#123; a[p],d[p] &#125;);</span><br><span class="line">            mks += a[p];</span><br><span class="line">            p++;</span><br><span class="line">            t = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!dq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                mks -= dq.<span class="built_in">front</span>().first;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            t = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h1 id="h.-robin-hood-archery"><a
href="https://codeforces.com/problemset/problem/2014/H">2014 H. Robin
Hood Archery</a></h1>
<p>通过简单的观察，只有这个区间的所有数都出现偶数次才可能平手，所以我们自然联想到用异或hash来处理：
由异或的性质，每个数的偶数次异或和结果为0。
于是一个区间的数都出现偶数次的必要条件于这个区间的随机异或和为0(充要前提是不发生hash碰撞)。
于是我们给每个数随机一个mt19937_64作为值，然后处理一下异或前缀和方便<span
class="math inline">\(O(1)\)</span>查询每个区间
<strong>(每个数异或逆元是它本身，即很好找到异或逆元，这是我们从前缀和得到区间和的必要条件，而像<span
class="math inline">\(\gcd\)</span>等运算根本没有逆元导致没办法处理前缀和之后就<span
class="math inline">\(O(1)\)</span>求解区间和)</strong>
之后就很简单了，如果异或和为0即为合法区间。</p>
<details>
<summary>
Code:
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, ll&gt;mp, status;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">hs</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (mp[a[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">            mp[a[i]] = <span class="built_in">rnd</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        hs[i] = mp[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        hs[i] ^= hs[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> ((hs[r] ^ hs[l - <span class="number">1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<p>这题好像也有莫队的做法，想想也可行(如果实现比较好不被卡常)</p>
<h1 id="e.-compatible-numbers"><a
href="https://codeforces.com/problemset/problem/165/E">165 E. Compatible
Numbers</a></h1>
<p>从某道最近的题来的S 一道sos dp典题，但是写的时候过于犯病</p>
<p>题意大概是给定一个非空多重集合，<span class="math inline">\(a_i \ge
1\)</span>。定义compatible(相容)<span
class="math inline">\(a\)</span>相容<span
class="math inline">\(b\)</span>为 <span class="math inline">\(a \&amp;
b =
0\)</span>,对集合中每个元素，求集合中与它相容的元素(不能是它本身或者相等的元素)</p>
<p>因为知道是sosdp，所以很快有思路： 每个元素<span
class="math inline">\(a_i\)</span>按位取反<span
class="math inline">\(\sim a_i\)</span>的子掩码都与<span
class="math inline">\(a_i\)</span>相容，我们直接用<span
class="math inline">\(a_i\)</span>的下标<span
class="math inline">\(i\)</span>初始化<span
class="math inline">\(dp[\sim
a_i]\)</span>，其他初始值为0,然后跑一遍sosdp即可。设置a[0] =
-1即可让<span class="math inline">\(ans[i] = a[dp[a[i]]]\)</span>;</p>
<p>sosdp的dp方法： 对每个位来一轮(假设为第<span
class="math inline">\(i\)</span>位)，遍历整个状态空间，如果该位置<span
class="math inline">\(p\)</span>这一位为1(<span
class="math inline">\((p&gt;&gt;i) \&amp; 1 == 1\)</span>)，则更新 <span
class="math display">\[dp[p \oplus 1&lt;&lt;i] = \max(dp[p],dp[p \oplus
1&lt;&lt;i])\]</span> 取max是为了防止被-1覆盖。</p>
<details>
<summary>
Code:
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m = <span class="number">22</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> p = <span class="number">1</span> &lt;&lt; m;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">msk</span>(p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        msk[(~a[i]) &amp; inf] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; p; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((j &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                msk[j ^ (<span class="number">1</span> &lt;&lt; i)] = <span class="built_in">max</span>(msk[j], msk[j ^ (<span class="number">1</span> &lt;&lt; i)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msk[a[i]])</span><br><span class="line">            cout &lt;&lt; a[msk[a[i]]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;&gt;</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>ProblemSet</category>
      </categories>
  </entry>
  <entry>
    <title>ABC378 每日一寄1st</title>
    <url>/2024/11/09/%E9%A2%98%E8%A7%A3/Atcoder/EverydayG/ABC378G/</url>
    <content><![CDATA[<h1 id="abc378-g---everlasting-lids-1st"><a
href="https://atcoder.jp/contests/abc378/tasks/abc378_g">ABC378 G -
Everlasting LIDS (1st)</a></h1>
<p>(是每日一寄的开始，虽然好像做不到每日一寄啦)</p>
<p><em>相关算法：序理论，杨表，钩长公式，dp</em></p>
<h2 id="part-1.题目概述">Part 1.题目概述</h2>
<p>题意很简单，给定限定<span
class="math inline">\(A,B\)</span>，要求构造出长为<span
class="math inline">\(A\cdot B-1\)</span>的且具有以下性质的排列<span
class="math inline">\(P\)</span>：<br />
1. 最长上升子序列(LIS)为<span class="math inline">\(A\)</span>.<br />
2. 最长下降子序列(LDS)为<span class="math inline">\(B\)</span>.<br />
3. 存在一个整数<span class="math inline">\(n\)</span>使得在<span
class="math inline">\(P\)</span>的末尾添加<span
class="math inline">\(n+0.5\)</span>不会改变最长递增子序列和最长递减子序列的长度</p>
<p>求可行的构造方案数，结果输出方案数模素数<span
class="math inline">\(M\)</span>。</p>
<h2 id="part-2.杨表">Part 2.杨表</h2>
<p>解决这题需要一些前置知识：杨表<br />
英式画法的杨表由有限个相邻的方格排列而成，其中，各横行的左边对齐，长度从上到下递增。<br />
<img src="\image\article_pics\at_evG\378\young-diagram-1.png"
alt="英式杨表" /> 标准杨表：在杨表的
n个方格中任意填入1到n中的相异正整数，各行和各列中的数字皆严格递增。<br />
<img src="\image\article_pics\at_evG\378\Completely-Young-diagram.png"
alt="标准杨表" />
显然，杨表代表着一种二维表示的偏序。而这种拓扑序可以与一个排列的LIS和LDS相关联。<br />
引入RSK算法(杨表的插入算法)：<br />
令 <span class="math inline">\(S\)</span> 是一个杨表，定义 <span
class="math inline">\(S \leftarrow x\)</span> 表示将 <span
class="math inline">\(x\)</span>
从第一行插入杨表中，具体如下：(引自oiwiki)<br />
1. 在当前行中找到最小的比 <span class="math inline">\(x\)</span> 大的数
<span class="math inline">\(y\)</span> 。<br />
2. 如果找到了，用 <span class="math inline">\(x\)</span> 去替换 <span
class="math inline">\(y\)</span>，移到下一行，令 <span
class="math inline">\(x \leftarrow y\)</span> 重复操作1。<br />
3. 如果找不到，就把 <span class="math inline">\(x\)</span>
放在该行末尾并退出。记 <span class="math inline">\(x\)</span> 在第 <span
class="math inline">\(s\)</span> 行第 <span
class="math inline">\(t\)</span> 列，<span class="math inline">\((s,
t)\)</span> 必定是一个边角。一个格子 <span class="math inline">\((s,
t)\)</span> 是边角当且仅当 <span class="math inline">\((s + 1,
t)\)</span> 和 <span class="math inline">\((s, t + 1)\)</span>
都不存在格子。</p>
<p>对于一个排列 <span class="math inline">\(P =
\{p_1,p_2,...p_n\}\)</span>,我们构造一个杨表<br />
<span class="math display">\[S = \emptyset \leftarrow p_1 \leftarrow p_2
\leftarrow ... \leftarrow p_n\]</span> 此外，我们定义一个记录表 <span
class="math inline">\(Q\)</span>，<span
class="math inline">\(Q_{s,t}\)</span> 为插入 <span
class="math inline">\(S\)</span> 位置 <span
class="math inline">\((s,t)\)</span> 时元素 <span
class="math inline">\(p_i\)</span> 的下标 <span
class="math inline">\(i\)</span>。<br />
可以预见:<br />
1. <span class="math inline">\(Q\)</span>
中元素也满足杨表的偏序关系(构造时是在已有格子的下方或右方插入更大的元素),故
<span class="math inline">\(Q\)</span> 也是一个杨表。<br />
2. 且 <span class="math inline">\(S\)</span> 和 <span
class="math inline">\(Q\)</span>
具有相同的形状(这是易从定义推出的)。</p>
<p>于是，通过一个排列 <span
class="math inline">\(P\)</span>，我们生成了一对杨表 <span
class="math inline">\(\{S,Q\}\)</span>。 将 <span
class="math inline">\(n\)</span> 元排列的集合记作 <span
class="math inline">\(\mathbb{P}\)</span>,<span
class="math inline">\(n\)</span> 元杨表的集合记作 <span
class="math inline">\(\mathbb{S}\)</span>,具有相同形状的杨表集合记作
<span class="math inline">\(\mathbb{S_{\lambda_i}}\)</span>,其中 <span
class="math inline">\(\lambda\)</span> 是整数 <span
class="math inline">\(n\)</span>
的一个分拆，这唯一对应了杨图的一个形状。 用 <span
class="math inline">\(\pi_\lambda\)</span> 表示这样形状的一个杨表。</p>
<p>以下不加证明给出一些结论,符号与上文意义保持一致:<br />
1. <span class="math inline">\(P\)</span> 的LIS等于 <span
class="math inline">\(S\)</span> 的第一行元素个数，LDS等于 <span
class="math inline">\(S\)</span> 的第一列元素个数。<br />
2. <span class="math inline">\(f : \mathbb{P} \rightarrow \sum_{\lambda
\vdash n} \mathbb{S_{\lambda}} \times
\mathbb{S_{\lambda}}\)</span>是双射。即从使用上文所属的RSK插入算法，不同排列得到的杨表对是不同的(单射)。更为重要的是这还是一个满射，也就是说可以得到所有的杨表对。因此也有：<span
class="math display">\[n! = A^n_n = \sum_{\lambda \vdash n}{(\dim
\pi_{\lambda})}^2\]</span><br />
3. 对于对于杨表中的一个方格 <span
class="math inline">\(v\)</span>，定义其勾长 <span
class="math inline">\(\mathrm{hook}(v)\)</span>
等于同行右边的方格数加上同列上面的方格数，再加 <span
class="math inline">\(1\)</span> （即方格本身）。如果用 <span
class="math inline">\(\dim \pi_{\lambda}\)</span>
表示这样的方法个数，方法个数就等于 <span
class="math inline">\(n!\)</span> 除以所有方格的勾长的乘积。<br />
有钩长公式:<span class="math display">\[\dim \pi _{\lambda} =
\frac{n!}{\prod_{x \in Y(\lambda)} \mathrm{hook}(x)}\]</span></p>
<p>现在，我们有了足够的理论基础来解决本题。</p>
<h2 id="part-3.分析">Part 3.分析</h2>
<p>由Part 2中的理论，长为 <span class="math inline">\(A\cdot B -
1\)</span> 的排列对应的杨表形状是唯一的，即一个 <span
class="math inline">\(A \times B\)</span>
的矩形去掉右下角一块。而条件3要求我们在 <span
class="math inline">\(P\)</span> 的末尾插入元素 <span
class="math inline">\(n + 0.5\)</span>
后LIS和LDS不变，那么对应的杨图应为 <span class="math inline">\(A \times
B\)</span> 的矩形了。<br />
考虑前面所述的RSK插入算法，对原杨表 <span
class="math inline">\(\pi\)</span>
插入一个元素后刚好到达右下角，那么只能是每次替换掉该行最后一个元素，然后向下传递。我们选取的元素应该为介于
<span class="math inline">\(\pi_{1,b-1}\)</span> 和 <span
class="math inline">\(\pi_{1,b}\)</span>，即<span
class="math inline">\(\pi_{1,b-1} &lt; n+0.5&lt;\pi_{1,b}\)</span>
。然后，这个数替换掉 <span class="math inline">\(\pi_{1,b}\)</span> ,
<span class="math inline">\(\pi_{1,b}\)</span>
接着向下传递，仍然重复这样的替换，那么条件是相似的。由于杨表的性质，已经有了
<span class="math inline">\(\pi_{i,b}&lt;\pi_{i+1,b}\)</span>
,故我们只需要求 <span
class="math inline">\(\pi_{i+1,b-1}&lt;\pi_{i,b}\)</span>
,便可以保持这种传递一直进行到最后一行。<br />
而构造出这样特定的杨表后，我们有 <span class="math inline">\(\dim \pi
_{\lambda}\)</span> 种记录表将其映射成一个合法的排列 <span
class="math inline">\(P\)</span>
(考虑我们前面所述的双射和映上性)。所以我们求解这道题，只需得到满足条件杨表的数量和
<span class="math inline">\(\dim \pi _{\lambda}\)</span>
，而后者只需要使用钩长公式即可。</p>
<h2 id="part-4.实现dp">Part 4.实现(DP)</h2>
<p>我们考虑使用dp来求解合法的杨表数量。<br />
模拟杨表的填入，我们顺序选取元素 <span class="math inline">\(1 \sim
A\cdot B-1\)</span> 填入，以减少不必要的check。<br />
考虑杨表的二维偏序性，我们不是在二维的矩阵上去枚举填入数字的位置，而是选择一维顺序填入，另一维枚举填入位置。(毕竟顺序选取元素时跨越式的填入是一定不符合杨表的限制的)<br />
为了方便检查分析的来的条件，我们顺序填入行，并枚举填入的列号。用一个vector
<span class="math inline">\(v\)</span>
来表示每列填入了多少行，设计状态<span
class="math inline">\(dp[v]\)</span>表示填入状态为<span
class="math inline">\(v\)</span>的方案数。我们顺序选取元素 <span
class="math inline">\(1 \sim A\cdot B-1\)</span>
填入，对于每个元素，我们枚举前一个元素填入后的所有状态，对每个状态枚举填入某列是否合法，若合法则从
<span class="math inline">\(v\)</span> 转移到合法状态 <span
class="math inline">\(u\)</span> 。状态转移方程：<br />
<span class="math display">\[dp[u] += dp[v]\]</span> 对 <span
class="math inline">\(v\)</span> 填入第 <span
class="math inline">\(i\)</span> 列合法所需的条件:<br />
1. <span class="math inline">\(v[i] \neq a \bigwedge (i = 0 \bigvee v[i]
&lt; v[i - 1])\)</span><br />
2. <span class="math inline">\(i \neq b - 1 \bigvee v[i] &lt; v[i - 1] -
1\)</span></p>
<p>我们用一个map来滚动记录状态并且dp。</p>
<p>code:(用了jls的模数板子，并且借鉴了一下别的大佬的思路)<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, m;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;</span><br><span class="line">    MInt&lt;<span class="number">0</span>&gt;::Mod = m;</span><br><span class="line">    <span class="keyword">using</span> Z = MInt&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line">    Z ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; a * b - <span class="number">1</span>; x++) &#123;</span><br><span class="line">        <span class="type">int</span> i = x / b, j = x % b;</span><br><span class="line">        ans *= (x<span class="number">+1</span>);</span><br><span class="line">        <span class="type">int</span> q = (a + b - i - j - <span class="number">1</span> - (i == a - <span class="number">1</span>) - (j == b - <span class="number">1</span>));</span><br><span class="line">        ans /= q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    map&lt;vector&lt;<span class="type">int</span>&gt;, Z&gt;dp;</span><br><span class="line">    dp[<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b,<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a * b - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        map&lt;vector&lt;<span class="type">int</span>&gt;, Z&gt;ndp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[v, c] : dp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i] != a &amp;&amp; (i == <span class="number">0</span> || v[i] &lt; v[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != b - <span class="number">1</span> || v[i] &lt; v[i - <span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> u = v;</span><br><span class="line">                        u[i]++;</span><br><span class="line">                        ndp[u] += c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = <span class="built_in">move</span>(ndp);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">getans</span>(b, a);</span><br><span class="line">    getans[b - <span class="number">1</span>]--;</span><br><span class="line">    ans *= dp[getans];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>模数板子： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">power</span><span class="params">(T a, i64 b)</span> </span>&#123;</span><br><span class="line">    T res&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> i64 <span class="title">mul</span><span class="params">(i64 a, i64 b, i64 p)</span> </span>&#123;</span><br><span class="line">    i64 res = a * b - <span class="built_in">i64</span>(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;i64 P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MInt</span> &#123;</span><br><span class="line">    i64 x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">()</span> : x&#123;</span> <span class="number">0</span> &#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">(i64 x)</span> : x&#123;</span> <span class="built_in">norm</span>(x % <span class="built_in">getMod</span>()) &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> i64 Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> i64 <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(i64 Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">norm</span><span class="params">(i64 x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MInt res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>*=(MInt rhs)&amp; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getMod</span>() &lt; (<span class="number">1ULL</span> &lt;&lt; <span class="number">31</span>)) &#123;</span><br><span class="line">            x = x * rhs.x % <span class="built_in">int</span>(<span class="built_in">getMod</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x = <span class="built_in">mul</span>(x, rhs.x, <span class="built_in">getMod</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>+=(MInt rhs)&amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>-=(MInt rhs)&amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>/=(MInt rhs)&amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>*(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>+(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>/(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, MInt&amp; a) &#123;</span><br><span class="line">        i64 v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MInt&amp; a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() &lt; rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">i64 MInt&lt;<span class="number">0</span>&gt;::Mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//constexpr int P = 1000000007;</span></span><br><span class="line"><span class="comment">//using Z = MInt&lt;P&gt;;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
        <category>EverydayG</category>
      </categories>
  </entry>
  <entry>
    <title>ABC379 每日一寄2nd</title>
    <url>/2024/11/11/%E9%A2%98%E8%A7%A3/Atcoder/EverydayG/ABC379G/</url>
    <content><![CDATA[<h1 id="abc379-g---count-grid-3-coloring-2nd"><a
href="https://atcoder.jp/contests/abc379/tasks/abc379_g">ABC379 G -
Count Grid 3-coloring (2nd)</a></h1>
<p>(G题之间亦有差距)</p>
<p><em>相关算法 : dp,枚举，复杂度估计</em></p>
<h2 id="part-1.题目概述">Part 1.题目概述</h2>
<p>一个 <span class="math inline">\(n \times m\)</span> 的矩阵，里面只有
<span class="math inline">\(1，2，3，?\)</span>,其中 <span
class="math inline">\(?\)</span>
为不确定的数。问有多少种可能使矩阵相邻元素不相同。其中 <span
class="math inline">\(n\cdot m &lt;= 200\)</span>。</p>
<h2 id="part-2.分析">Part 2.分析</h2>
<p>我们考虑从上到下从左到右逐格dp来确定每格的不同状态可能的情况。</p>
<h3 id="dp设计">dp设计</h3>
<p>设 <span class="math inline">\(dp[i][val]\)</span> 为填到第 <span
class="math inline">\(i\)</span> 个格子值为 <span
class="math inline">\(val\)</span> 时的状态数。
首先我们思考：如果按照上面所述的顺序填入数字，那么每格的状态和哪些格子直接相关呢？(这关乎我们状态的设计和转移的方式，dp无后效性的重要性质也在这里体现)<br />
显然，答案是左邻格和上邻格(如果有的话)。那么我们得知这两个一起的状态时，就可以转移到目前格的状态。不过重要的是"一起的状态",也就是一个键值。这里是不能分开的(因为我们dp的状态含义本身就是填到第多少格为止的状态，分开考虑显然会将前面的部分重叠)。<br />
但是，如何得到每个格子对应的键值来连续地去转移来dp呢？我们需要在dp时去记录一些有必要的信息。
我们是连续填入的，所以每个格子需要的dp信息要在上一个里面，而每个格子需要的最早的信息是上邻格的状态(与左邻格状态的组合)。再稍加归纳，我们需要也只需要记录一整行的状态即可。转移起来则是舍去上邻格状态，加入本格状态，转移到下一格。</p>
<h3 id="dp优化">dp优化</h3>
<p>我们再考虑dp的优化。<br />
首先，第一维是可以滚动掉的，所以我们只需要一个数组记录每行的合法状态，最多
<span class="math inline">\(9\cdot 2^m\)</span>
个。每次转移起来则需要<span class="math inline">\(O(m)\)</span>。<br />
1. 对于状态数，<span
class="math inline">\(2^m\)</span>可能达到一个很大的值，但是<span
class="math inline">\(\min(n,m)\)</span>是小于<span
class="math inline">\(\sqrt
{200}\)</span>的。因为我们是以一行的状态进行转移，考虑到对称性，我们可以选择数值较小的一维作为行(即
<span class="math inline">\(n &lt;
m\)</span>时进行一个转置操作)，把我们每行的状态数维持在一个可控的状态。<br />
2. 对于每次转移的开销，<span
class="math inline">\(m\)</span>虽然不大，但是<span
class="math inline">\(O(m)\)</span>的转移仍有tle的风险。虽然我们每次修改头尾，可以使用队列一类的数据结构，但是实际上我们有更好的选择——状态压缩。<br />
由于每个格点只有<span
class="math inline">\(0\)</span>(我们保持dp状态都为一整行的状态，所以最开始全部设置为0)<span
class="math inline">\(,1,2,3\)</span>四种状态，用两位进制数即可表示，所以我们可以把一行最多14个数的状态压缩成一个unsigned
int。转移和check的时候使用位运算即可很方便地实现<span
class="math inline">\(O(1)\)</span>的转移。<br />
3.
最后，我们还需要来记录所有的状态，实现滚动。map&lt;uint,Z&gt;是一个很好的选择，毕竟键值是离散的。但是实际上还可以优化。<br />
考虑我们在转移时枚举的状态。不同前状态转移后的状态相等，当且仅当这两个前状态仅有上邻格状态是不同的。如果我们外层枚举前状态，内层枚举该格的值，那么两个相同的后状态是可能由两个相同的前状态得来的。但是如果外层枚举该格的值，内层枚举前状态，那么两个相同的后状态，一定由两个相邻的前状态枚举出来！
这里比较抽象，可以类比想象对字符串做类似的操作。对一个有序的字符串集合<span
class="math inline">\(S\)</span>，初始只有一个有长度的零串。如果我们有序遍历<span
class="math inline">\(S\)</span>,删除前缀并按字典序添加后缀，如此循环往复几轮<span
class="math inline">\(S\)</span>也是混乱无序的。因为有序添加的后缀是在连续变动的，是内层的序，后续状态也会是不连续的。但是如果我们有序选择添加的后缀，遍历集合进行操作，那么连续操作后，<span
class="math inline">\(S\)</span>仍然是按照一个倒的字典序排列的，因为我们所期望的序在外层循环，是不连续变动的，<strong>而连续变动的是我们即将删掉的部分</strong>，不会影响。<br />
<strong>总的来说，就是将即将删除的位置作为内层循环，离删除最远的，新的位置作为外层循环，以实现枚举状态的连续性。</strong><br />
因此，我们可以使用后一种枚举方式，而将map改成vector，对于得到的合法状态，我们只需判断是否等于最后一个元素，进行相应的操作即可。这样我们就把<span
class="math inline">\(O(\Omega \log{\Omega})\)</span>的枚举优化成了<span
class="math inline">\(O(\Omega)\)</span>.</p>
<h2 id="part-3-实现">Part 3 实现</h2>
<p>实际上不需要第三条优化，即可通过本题。但是第三条优化将1400+ms优化为42ms，或许值得仔细思考这种遍历顺序选取的技巧。
code: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;string&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">        vector&lt;string&gt;<span class="built_in">na</span>(m, <span class="built_in">string</span>(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                na[i][j] = a[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a = <span class="built_in">move</span>(na);</span><br><span class="line">        <span class="built_in">swap</span>(n, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;uint, Z&gt;&gt;dp;</span><br><span class="line">    <span class="comment">//map&lt;uint, Z&gt;dp;</span></span><br><span class="line">    <span class="type">int</span> r = (m - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    uint inf = (<span class="built_in">uint</span>(<span class="number">1</span>) &lt;&lt; (m * <span class="number">2</span>)) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//dp[uint(0)] = 1;</span></span><br><span class="line">    dp.<span class="built_in">emplace_back</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            vector&lt;pair&lt;uint, Z&gt;&gt;ndp;</span><br><span class="line">            <span class="comment">//map&lt;uint, Z&gt;ndp;</span></span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">3</span>; val++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : dp) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((i == <span class="number">0</span> || ((v &gt;&gt; r) &amp; <span class="number">3</span>) != val) &amp;&amp; (j == <span class="number">0</span> || (v &amp; <span class="number">3</span>) != val)) &#123;</span><br><span class="line">                            uint nv = ((v &lt;&lt; <span class="number">2</span>) &amp; inf) | val;</span><br><span class="line">                            <span class="keyword">if</span> (!ndp.<span class="built_in">empty</span>() &amp;&amp; ndp.<span class="built_in">back</span>().first == nv)</span><br><span class="line">                                ndp.<span class="built_in">back</span>().second += c;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                ndp.<span class="built_in">emplace_back</span>(nv, c);</span><br><span class="line">                            <span class="comment">//ndp[nv] += c;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> val = a[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : dp) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i == <span class="number">0</span> || ((v &gt;&gt; r) &amp; <span class="number">3</span>) != val) &amp;&amp; (j == <span class="number">0</span> || (v &amp; <span class="number">3</span>) != val)) &#123;</span><br><span class="line">                        uint nv = ((v &lt;&lt; <span class="number">2</span>) &amp; inf) | val;</span><br><span class="line">                        <span class="keyword">if</span> (!ndp.<span class="built_in">empty</span>() &amp;&amp; ndp.<span class="built_in">back</span>().first == nv)</span><br><span class="line">                            ndp.<span class="built_in">back</span>().second += c;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            ndp.<span class="built_in">emplace_back</span>(nv, c);</span><br><span class="line">                        <span class="comment">//ndp[nv] += c;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = <span class="built_in">move</span>(ndp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Z ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [v, c] : dp)</span><br><span class="line">        ans += c;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">power</span><span class="params">(T a, i64 b)</span> </span>&#123;</span><br><span class="line">    T res&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> i64 <span class="title">mul</span><span class="params">(i64 a, i64 b, i64 p)</span> </span>&#123;</span><br><span class="line">    i64 res = a * b - <span class="built_in">i64</span>(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;i64 P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MInt</span> &#123;</span><br><span class="line">    i64 x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">()</span> : x&#123;</span> <span class="number">0</span> &#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">(i64 x)</span> : x&#123;</span> <span class="built_in">norm</span>(x % <span class="built_in">getMod</span>()) &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> i64 Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> i64 <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(i64 Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">norm</span><span class="params">(i64 x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MInt res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>*=(MInt rhs)&amp; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getMod</span>() &lt; (<span class="number">1ULL</span> &lt;&lt; <span class="number">31</span>)) &#123;</span><br><span class="line">            x = x * rhs.x % <span class="built_in">int</span>(<span class="built_in">getMod</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x = <span class="built_in">mul</span>(x, rhs.x, <span class="built_in">getMod</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>+=(MInt rhs)&amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>-=(MInt rhs)&amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>/=(MInt rhs)&amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>*(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>+(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>/(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, MInt&amp; a) &#123;</span><br><span class="line">        i64 v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MInt&amp; a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() &lt; rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">i64 MInt&lt;<span class="number">0</span>&gt;::Mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Z = MInt&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
        <category>EverydayG</category>
      </categories>
  </entry>
  <entry>
    <title>ABC379 每日一寄3rd</title>
    <url>/2024/11/15/%E9%A2%98%E8%A7%A3/Atcoder/EverydayG/ABC377G/</url>
    <content><![CDATA[<h1 id="abc377-g---edit-to-match-3rd"><a
href="https://atcoder.jp/contests/abc377/tasks/abc377_g">ABC377 G - Edit
to Match (3rd)</a></h1>
<p>(挺简单的，不过看来得好好学一下字符串算法了)</p>
<p><em>相关算法： 字典树</em></p>
<h2 id="part-1.题目概述">Part 1.题目概述</h2>
<p>按顺序给出<span
class="math inline">\(N\)</span>个字符串，对于每个字符串，有两种操作，代价均为1：<br />
1. 删掉最后一个字母 2. 在最后加上任意一个字母</p>
<p>求让每个字符串变成前面任一字符串或者空串的最小代价。</p>
<h2 id="part-2.分析">Part 2.分析</h2>
<p>由于对第 <span class="math inline">\(i\)</span> 个串 <span
class="math inline">\(S\)</span> 处理时，要考虑前面 <span
class="math inline">\(i-1\)</span>
个串的匹配问题，很自然想到对前面的串建一棵字典树(trie)。建立字典树时，我们同时记录每个节点到叶子节点的最小距离，那么我们遍历
<span class="math inline">\(S\)</span> 时，很容易就可以统计出答案。</p>
<h2 id="part-3.实现">Part 3.实现</h2>
<p>第一次写字典树，前后写了很多很dirty的代码。最后是用链表实现的trie，感觉比数组慢了不少。
对于插入操作，我们递归建树，同时返回与叶子节点的距离，以更新父节点与叶子节点最短距离的信息。对于查询答案的操作，我们遍历字符串，用
<span class="math inline">\(f[p]\)</span> 表示删除 <span
class="math inline">\(S\)</span> 为字串 <span
class="math inline">\(S(0,p)\)</span>,然后再用最少步骤补成一个合法的串的代价。很容易得出
<span class="math inline">\(f[p] = |S| - p - 1 + dist(p)\)</span>.<br />
code: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf = INT_MAX / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;node*&gt;nxt;</span><br><span class="line">    <span class="type">int</span> bottow;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">node</span>()</span><br><span class="line">        :<span class="built_in">nxt</span>(<span class="built_in">vector</span>&lt;node*&gt;(<span class="number">26</span>,<span class="literal">nullptr</span>)),<span class="built_in">bottow</span>(inf)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            bottow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> bottow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> ni = s[p] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (nxt[ni] == <span class="literal">nullptr</span>)</span><br><span class="line">                nxt[ni] = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">            <span class="keyword">return</span> bottow = <span class="built_in">min</span>(bottow, nxt[ni]-&gt;<span class="built_in">insert</span>(s, p + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getans</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> p)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = s.<span class="built_in">length</span>() - p + bottow;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; s.<span class="built_in">length</span>() &amp;&amp; nxt[s[p] - <span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, nxt[s[p] - <span class="string">&#x27;a&#x27;</span>]-&gt;<span class="built_in">getans</span>(s, p + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;string&gt;<span class="built_in">s</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    node root = <span class="built_in">node</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>((<span class="type">int</span>)s[i].<span class="built_in">length</span>(),root.<span class="built_in">getans</span>(s[i],<span class="number">0</span>)) &lt;&lt; endl;</span><br><span class="line">        root.<span class="built_in">insert</span>(s[i],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一开始写了很糖的代码，感觉还是得学习一下各种数据结构和算法的优秀写法才行。写出比较通用的规范的代码或许会更好。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
        <category>EverydayG</category>
      </categories>
  </entry>
  <entry>
    <title>CF Round988 div3</title>
    <url>/2024/11/19/%E9%A2%98%E8%A7%A3/Codeforces/Contest/cf_round988_div3/</url>
    <content><![CDATA[<h1 id="cf-round988-div3"><a
href="https://codeforces.com/contest/2037/">CF Round988 div3</a></h1>
<h1 id="c"><a
href="https://codeforces.com/contest/2037/problem/C">C</a></h1>
<p>很简单的构造。<br />
<span class="math inline">\(n \leq
4\)</span>的时候是不可能的，很容易试探出来。<br />
对于剩下的情况，由于偶数除了2都是合数，而两个不同的大于1的数的和均大于2，所以我们可以把奇数放一起，偶数放一起，此时只有分界处两数奇偶性不同，可能为质数。而此时我们可以选取4，5作为分界点的数。于是很容易构造出符合题意的排列。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(n);</span><br><span class="line">        ans[(n<span class="number">-1</span>) / <span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">        ans[(n<span class="number">-1</span>) / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; i != <span class="number">5</span>) &#123;</span><br><span class="line">                ans[p] = i;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p = (n <span class="number">-1</span>)/ <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">4</span>) &#123;</span><br><span class="line">                ans[p] = i;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="d"><a
href="https://codeforces.com/contest/2037/problem/D">D</a></h1>
<p>也很简单。遍历整个障碍序列，对于每个障碍，贪心地选取可以选的最大的能量符直至可以跳过该障碍为止，然后再去考虑下一个障碍。<br />
可以用一个优先队列来维护可供选择的能量符。<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, l;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; l;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;<span class="built_in">b</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i].first &gt;&gt; b[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pb &lt; m &amp;&amp; b[pb].first &lt; a[i].first) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(b[pb].second);</span><br><span class="line">            pb++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = a[i].second - a[i].first + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; sum &lt; len) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            sum += q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; len) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="e"><a
href="https://codeforces.com/contest/2037/problem/E">E</a></h1>
<p>分析题意，我们需要选取一个合适的询问序列来确定这个01串。<br />
考虑顺序询问区间 <span class="math inline">\([1,j],j =
2,3,...n\)</span>，我们可以发现如果<span
class="math inline">\(f(1,j)\)</span>大于前面一个询问值，那么<span
class="math inline">\(s[j]\)</span>一定是<span
class="math inline">\(1\)</span>,否则如果<span
class="math inline">\(f(1,j) \neq 0\)</span>,则 <span
class="math inline">\(s[j]\)</span> 为0。<br />
还剩余<span class="math inline">\(f[1,j] =
0\)</span>的情况，我们考虑<span
class="math inline">\(f\)</span>第一次非0的位置，此时<span
class="math inline">\(s[1,j]\)</span>应该是形如<span
class="math inline">\(11...10000...01\)</span>的串，而0的个数为<span
class="math inline">\(f\)</span>，我们也很好确定前导 <span
class="math inline">\(1\)</span> 的个数。<br />
最后，如果我们所有的询问得到的<span
class="math inline">\(f\)</span>全都为0，那么这个串是形如<span
class="math inline">\(111...11000...00\)</span>的串，而且无法确定0，1的个数，其他任何询问得到的<span
class="math inline">\(f\)</span>也均为0，所以按照题意我们应该输出IMPOSSIBLE.<br />
code：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">string <span class="title">ans</span><span class="params">(n + <span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        cout.<span class="built_in">flush</span>();</span><br><span class="line">        <span class="type">int</span> f;</span><br><span class="line">        cin &gt;&gt; f;</span><br><span class="line">        <span class="keyword">if</span> (f &gt; sum &amp;&amp; flg) &#123;</span><br><span class="line">            sum = f;</span><br><span class="line">            flg = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i - f - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                ans[j] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f &gt; sum &amp;&amp; !flg)&#123;</span><br><span class="line">            sum = f;</span><br><span class="line">            ans[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f == sum &amp;&amp; flg) &#123;</span><br><span class="line">            ans[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flg) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;! IMPOSSIBLE&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="f"><a
href="https://codeforces.com/contest/2037/problem/F">F</a></h1>
<p>赛时没想到二分答案，还是太菜了。<br />
实际上对于最少次数二分一下，check一下能不能即可。<br />
check可以使用一个类似滑动窗口的算法，在给定攻击次数的情况下，计算出每个敌人可以被打死的左端点和右端点，然后把左端点数组和右端点数组排序，使用双指针计算同时在可击杀范围内最多敌人数即可。<br />
时间复杂度<span class="math inline">\(O(n\log n \log H)\)</span><br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">h</span>(n), <span class="built_in">x</span>(n);</span><br><span class="line">    <span class="type">int</span> maxh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">        maxh = <span class="built_in">max</span>(maxh, h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> inf = INT_MAX / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> L = <span class="number">1</span>, R = maxh + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (R + L) / <span class="number">2</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">l</span>(n), <span class="built_in">r</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> at = (h[i] + mid - <span class="number">1</span>) / mid;</span><br><span class="line">            l[i] = x[i] - m + at;</span><br><span class="line">            r[i] = <span class="built_in">max</span>(l[i],x[i] + m - at + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//stable_sort(l.begin(), l.end());</span></span><br><span class="line">        <span class="comment">//stable_sort(r.begin(), r.end());</span></span><br><span class="line">        <span class="built_in">sort</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> p = -inf;</span><br><span class="line">        <span class="type">int</span> pl = <span class="number">0</span>, pr = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (pl &lt; n &amp;&amp; pr &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[pl] &lt; r[pr]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                pl++;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= k) &#123;</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l[pl] &gt; r[pr]) &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                pr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pl++;</span><br><span class="line">                pr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            R = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L == maxh + <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="g"><a
href="https://codeforces.com/contest/2037/problem/G">G</a></h1>
<p>很有意思和启发性的题，也算是在学习一些数论知识后第一次用到了莫比乌斯(Möbius)函数。
题意大概是一个有向图有编号为1-n的点，有点权<span
class="math inline">\(v_i\)</span>。当且仅当<span
class="math inline">\(i &lt; j\)</span> 且 <span
class="math inline">\(\gcd(a_i,a_j) \neq 1\)</span>时有<span
class="math inline">\(a_i\)</span>到<span
class="math inline">\(a_j\)</span>的边。求点1到点n的路径数。点数为<span
class="math inline">\(2 \sim 1e5\)</span>,点权范围为<span
class="math inline">\(2 \sim 1e6\)</span>。<br />
首先，肯定不能两层循环预处理出所有路径，这是<span
class="math inline">\(n^2\)</span>的。但是考虑到路径与<span
class="math inline">\(\gcd\)</span>的关联，我们可以通过筛一个点权的所有因数，来获得图中的一个个团(虽然不是双向边)。而可以想到的是，质数对应的团是极大的。<br />
考虑到这是一个有向图，我们如果把所有具有共同因数的点的集合先处理好了再计数，转移反而很麻烦。所以我们考虑边把点加进来边计数。<br />
我们约定记号<span
class="math inline">\(path[i]\)</span>表示到下标为<span
class="math inline">\(i\)</span>的点的路径数，<span
class="math inline">\(sum[fac]\)</span>表示具有共同因子<span
class="math inline">\(fac\)</span>的所有点的路径数之和。<br />
于是对于一个新加进来的点，到它的路径数应该等于和他具有相同非1因子的点的路径数的总和。显然我们不能一个一个去找这些点，否则算法复杂度最坏会到<span
class="math inline">\(n^2\)</span>，但是我们可以利用<span
class="math inline">\(sum\)</span>数组来求解。<br />
如何用<span
class="math inline">\(sum\)</span>的组合来表示这个集合(指前面所述的具有相同非1因子的点)的贡献呢？我们从集合的角度考虑。假设新加进来的点权<span
class="math inline">\(v = p_1^{k_1}
p_2^{k_2}...p_k^{k_k}\)</span>,那么对于的集合应该是<span
class="math inline">\(p_1,p_2,\dots,p_k\)</span>这些质因数代表集合的并集。于是可以自然的想到容斥定理。按照容斥定理，我们考虑<span
class="math inline">\(v\)</span>的所有非1因子<span
class="math inline">\(f\)</span>,并将其分成两类：<br />
1. <span class="math inline">\(f\)</span> 是 <span
class="math inline">\(k\)</span>个不同质数的乘积(可以是一个)，那么这代表着容斥公式中的一项。对节点的贡献是<span
class="math inline">\((-1)^{k+1} \cdot sum[f]\)</span>。<br />
2. 存在质数<span class="math inline">\(p\)</span>,<span
class="math inline">\(p^2 |
f\)</span>，那么这不是容斥公式中的一项(理解这点可以想象一下veen图，交集处每个质因子的幂次要么是1，要么是0)。那么它对节点的贡献是0,或者说，<span
class="math inline">\(sum[f]\)</span>前乘上的系数是0.</p>
<p>如果你学过Möbius函数，我们会发现我们在<span
class="math inline">\(sum[f]\)</span>前乘上的系数简直就是<span
class="math inline">\(\mu(x)\)</span>的定义！唯一不同的是正负刚好相反。</p>
<p><span class="math inline">\(\mu\)</span> 为莫比乌斯函数，定义为 <span
class="math display">\[\begin{align*}
    \mu(n)=\left\{
        \begin{array}{ll}
        1&amp;n=1\\
        0&amp;\exists p,p^2 | n\\
        (-1)^k&amp;n = p_1 \cdot p_2...p_k\\
        \end{array}
    \right.
\end{align*}\]</span></p>
<p><span
class="math inline">\(\mu\)</span>是一个积性函数，而几乎所有的积性函数都可以使用欧拉筛法以线性时间筛出来，<span
class="math inline">\(\mu\)</span>并不例外。<br />
于是我们可以预处理<span class="math inline">\(1 \sim
1e6\)</span>范围内的<span
class="math inline">\(\mu(x)\)</span>,然后对于每个新加进来的点，在<span
class="math inline">\(\sqrt v\)</span>内筛出所有因数，对于每个因数<span
class="math inline">\(f\)</span>，我们计入贡献<span
class="math inline">\(-\mu(f) \cdot
sum[f]\)</span>。计算完后，再将这个节点的贡献加入所有它因数的集合贡献中去。<br />
有计算公式：<br />
<span class="math display">\[ path[i] = \sum_{f|v_i} -\mu(f) \cdot
sum[f] \]</span> 于是我们得出一个这题的一个解法，时间复杂度<span
class="math inline">\(O(n\sqrt V)\)</span>。<br />
(实际上对于和<span
class="math inline">\(\gcd\)</span>相关的容斥与莫比乌斯函数的深入联系仍值得探究，这里只是浅显地揭示了它们在形式上的对应关系，不过就容我先偷个懒吧，这件事以后再说)<br />
code:<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_N 1000001</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isprime</span><span class="params">(MAX_N, <span class="literal">true</span>)</span></span>;<span class="comment">//bool  </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mu</span><span class="params">(MAX_N)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_mu</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = MAX_N - <span class="number">1</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//index[i] = prime.size();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i * prime[j] &lt; n; j++) &#123;</span><br><span class="line">            isprime[i * prime[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * prime[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mu[i * prime[j]] = -mu[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">power</span><span class="params">(T a, i64 b)</span> </span>&#123;</span><br><span class="line">    T res&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> i64 <span class="title">mul</span><span class="params">(i64 a, i64 b, i64 p)</span> </span>&#123;</span><br><span class="line">    i64 res = a * b - <span class="built_in">i64</span>(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;i64 P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MInt</span> &#123;</span><br><span class="line">    i64 x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">()</span> : x&#123;</span> <span class="number">0</span> &#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">(i64 x)</span> : x&#123;</span> <span class="built_in">norm</span>(x % <span class="built_in">getMod</span>()) &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> i64 Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> i64 <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(i64 Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">norm</span><span class="params">(i64 x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MInt res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>*=(MInt rhs)&amp; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getMod</span>() &lt; (<span class="number">1ULL</span> &lt;&lt; <span class="number">31</span>)) &#123;</span><br><span class="line">            x = x * rhs.x % <span class="built_in">int</span>(<span class="built_in">getMod</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x = <span class="built_in">mul</span>(x, rhs.x, <span class="built_in">getMod</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>+=(MInt rhs)&amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>-=(MInt rhs)&amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>/=(MInt rhs)&amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>*(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>+(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>/(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, MInt&amp; a) &#123;</span><br><span class="line">        i64 v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MInt&amp; a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() &lt; rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">i64 MInt&lt;<span class="number">0</span>&gt;::Mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Z = MInt&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">get_mu</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">1000001</span>;</span><br><span class="line">    vector&lt;Z&gt;<span class="built_in">path</span>(N);</span><br><span class="line">    vector&lt;Z&gt;<span class="built_in">node</span>(n + <span class="number">1</span>);</span><br><span class="line">    node[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        cin &gt;&gt; v;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;fac;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">sqrt</span>(v); j++) &#123;<span class="comment">// use Möbius</span></span><br><span class="line">            <span class="keyword">if</span> (v % j == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">1</span>) &#123;</span><br><span class="line">                    node[i] += -mu[j] * path[j];</span><br><span class="line">                    fac.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j * j != v) &#123;                                                        </span><br><span class="line">                    node[i] += -mu[v / j] * path[v / j];</span><br><span class="line">                    fac.<span class="built_in">push_back</span>(v / j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : fac) &#123;</span><br><span class="line">            path[p] += node[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; node[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>Contest</category>
      </categories>
  </entry>
  <entry>
    <title>ABC379 每日一寄4th</title>
    <url>/2024/11/23/%E9%A2%98%E8%A7%A3/Atcoder/EverydayG/ABC376G/</url>
    <content><![CDATA[<h1 id="abc376-g---treasure-hunting"><a
href="https://atcoder.jp/contests/abc376/tasks/abc376_g">ABC376 G -
Treasure Hunting</a></h1>
<p><em>相关算法：贪心，组合数学</em></p>
<h2 id="part-1-题意简述">Part 1 题意简述</h2>
<p>给定一颗<span class="math inline">\(n+1\)</span>个节点的以<span
class="math inline">\(0\)</span>为根的树,每个点有点权<span
class="math inline">\(v\)</span>,每个点有宝藏的概率为<span
class="math inline">\(\frac{v_i}{\sum
v}\)</span>。认为根已搜寻，可以搜寻一个节点当且仅当搜寻过它的父节点。求搜寻到宝藏的步数的最小期望。<br />
当然，这个题意可以变换一下，即求一个访问序列<span
class="math inline">\(p\)</span>(这是一个长为<span
class="math inline">\(n\)</span>的排列)最小化<span
class="math inline">\(\sum_{i = 1}^{n} i\cdot
v_{p_i}\)</span>(这里我们提出来公因子<span
class="math inline">\(\frac{1}{\sum v}\)</span>),<span
class="math inline">\(p\)</span>中父节点的下标严格小于子节点的下标。<br />
数据范围: <span class="math inline">\(1≤N≤2×10^5\)</span>, <span
class="math inline">\(\sum v \leq 1 \times 10^8\)</span></p>
<h2 id="part-2-分析">Part 2 分析</h2>
<p>这是一个树上问题，可能我们会想到做一个树形dp，但是这不好做到无后效性，因为实际上可能在很长的间隔下选取同一颗子树的一些节点。<br />
由于这是一个最优化的问题，我们可以有一个想法，就是想kruskal算法求解最小生成树一样，我们贪心地去合并一些最优的点对，最后将整棵树合并成一个点。不过这里需要注意的是我们是合并点，而不是子树，因为一次选完一棵子树可能不会是最优的。<br />
此时我们有了一个贪心的思路，接下来我们完善它并且证明它的正确性。<br />
我们认为每个点集有两个值：大小<span
class="math inline">\(size\)</span>和期望值<span
class="math inline">\(val\)</span>。其中<span
class="math inline">\(val\)</span>代表着遍历这个点集的<strong>最大</strong>期望贡献。我们将两个点集<span
class="math inline">\(p,fa\)</span> (<span
class="math inline">\(fa\)</span>是<span
class="math inline">\(p\)</span>的父点集) 合并成新的点集时，有 <span
class="math display">\[size =  size_p + size_{fa}, val = val_{fa} +
size_{fa}\times val_p\]</span> 我们贪心地在每一步都选择让全局<span
class="math inline">\(\sum
val\)</span>增量最大的合并方式，如果我们将合并增量<span
class="math inline">\(size_{fa}\times val_p\)</span>当作边<span
class="math inline">\(\{fa,p\}\)</span>的边权，那么我们要做的就是每次选取边权最大的边做合并。最后合并到只剩一个点集时，我们得到的期望值<span
class="math inline">\(val\)</span>就是<strong>最小</strong>期望值。<br />
这一听或许很怪，毕竟我们贪心选择最大的合并方式，反而得到的是最小的期望值。但是仔细想想，我们优先访问大的增量的，那么在访问顺序上它会靠前，最终乘上的就是一个相对较小的系数。反而我们如果贪心选择最小增量的合并方式，那么最终最大的合并方式会乘上一个最大的系数，导致我们的期望值是最大的。<br />
当然，我们只是形式上分析了一下为什么这种贪心方式是最小期望的，严谨的证明如下(之后再补)。</p>
<h2 id="part-3-优化">Part 3 优化</h2>
<p>虽然我们的贪心选法和kruskal生成树的求法很像，但这并不是<span
class="math inline">\(O(n\log
n)\)</span>的算法，因为我们每次合并会改变<span
class="math inline">\(size\)</span>值，进而改于其相连的边的边权。这导致我们每步更新和找出边权最大的边可能是<span
class="math inline">\(O(n)\)</span>的。优化这个算法看起来很无解，不过考虑到我们定义点集的属性是仿照期望的求和式的形式去定义的，或许我们改变期望的表达式，推出一种新的贪心方法，从而得到一种新的求解最大合并增量的方式。<br />
设<span
class="math inline">\(v_p\)</span>数组的<strong>后缀和数组</strong>为<span
class="math inline">\(s\)</span>,有: <span
class="math display">\[\sum_{i = 1}^{n} i\cdot v_{p_i} = \sum_{i =
1}^{n} s_i\]</span>
我们做类似的点集定义，但是贪心方式变成对点去贪心。考虑到我们要最小化后缀和数组的和，我们每次选取最优的后缀和点集，把它接到它的父点集上形成一个新的后缀和。显然，这样的操作不会影响其他点集。我们再借助并查集来维护各个点集的成员，用优先队列来维护点集代表的后缀和大小，其中的偏序关系是<span
class="math inline">\(\frac{s}{size}\)</span>的大小(按照这个大小排序，可以保证接在同一个点集上的顺序是最优的)，可以做到<span
class="math inline">\(O(n\log n)\)</span>。我们的合并转移公式是类似的：
<span class="math display">\[size =  size_p + size_{fa}, s = s_{fa} +
size_{fa}\times s_p\]</span>
这里也可以给出一个证明去证明这种方式与对边贪心是等价的。 最终的实现code:
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    ll c0;</span><br><span class="line">    ll c1;</span><br><span class="line">    ll val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">node</span>(ll i, ll x, ll y)</span><br><span class="line">        :<span class="built_in">idx</span>(i),<span class="built_in">c0</span>(x), <span class="built_in">c1</span>(y),<span class="built_in">val</span>(x)</span><br><span class="line">    &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(node&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val = val + other.val + c1 * other.c0;</span><br><span class="line">        c0 += other.c0;</span><br><span class="line">        c1 += other.c1;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; other)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> c0 * other.c1 &lt; other.c0 * c1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> node&amp; other)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (c0 == other.c0 &amp;&amp; c1 == other.c1 &amp;&amp; val == other.val &amp;&amp; idx == other.idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">val</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">fa</span>(n + <span class="number">1</span>), <span class="built_in">c</span>(n + <span class="number">1</span>);</span><br><span class="line">    Z sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; fa[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum += a[i];</span><br><span class="line">        val[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">djs</span>(n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">sz</span>(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    vector&lt;node&gt;nds;</span><br><span class="line">    nds.<span class="built_in">push_back</span>(<span class="built_in">node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nds.<span class="built_in">push_back</span>(<span class="built_in">node</span>(i, a[i], <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> p)-&gt;<span class="type">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> djs[p] == <span class="number">-1</span> ? p : (djs[p] = <span class="built_in">self</span>(self, djs[p]));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> Find = [&amp;](<span class="type">int</span> p)-&gt;<span class="type">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(find, p);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> Union = [&amp;](<span class="type">int</span> p, <span class="type">int</span> f)-&gt;<span class="type">void</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">Find</span>(p);</span><br><span class="line">            <span class="type">int</span> b = <span class="built_in">Find</span>(f);</span><br><span class="line">            <span class="keyword">if</span> (a == b)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                djs[a] = b;</span><br><span class="line">                sz[b] += a;</span><br><span class="line">                nds[b].<span class="built_in">merge</span>(nds[a]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(nds[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> nd = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> p = nd.idx;</span><br><span class="line">        <span class="built_in">Union</span>(p, fa[p]);</span><br><span class="line">        q.<span class="built_in">push</span>(nds[<span class="built_in">Find</span>(p)]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">top</span>().idx != <span class="number">0</span> &amp;&amp; q.<span class="built_in">top</span>() == nds[q.<span class="built_in">top</span>().idx]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Z ans = nds[<span class="built_in">Find</span>(<span class="number">1</span>)].val;</span><br><span class="line">    ans /= sum;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Atcoder</category>
        <category>EverydayG</category>
      </categories>
  </entry>
  <entry>
    <title>Dsu on tree练习</title>
    <url>/2025/03/01/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/2025Dsu_on_tree/</url>
    <content><![CDATA[<h1 id="dsu-on-tree">DSU on tree</h1>
<p>即树上启发式合并。<br />
算法流程通常是通过dfs处理出树上每个点的重儿子，然后通过一个dfs算法来计算答案。对于一个节点，我们从重儿子继承信息，暴力合并轻儿子的信息，同时处理出每个点/点对/...对答案的贡献。<br />
如果我们暴力合并轻儿子的时间复杂度和轻子树的大小成线性关系，那么由重链剖分的性质，一个点到根的路径最多有<span
class="math inline">\(\log
n\)</span>条轻边，那么每个点的贡献实际上是<span
class="math inline">\(logn\)</span>级的，那么总的合并轻子复杂度为<span
class="math inline">\(O(n\log
n)\)</span>(实际上这个常数很小，因为每个点最多只有<span
class="math inline">\(\log n\)</span>次贡献，很多点取不到这么大)<br />
我们继承重子的操作数量级是<span
class="math inline">\(O(n)\)</span>的，如果我们可以确保每次继承重子的复杂度在<span
class="math inline">\(O(1)\)</span>或者<span
class="math inline">\(O(\log
n)\)</span>的话，那么启发式合并总的时间复杂度在<span
class="math inline">\(O(n\log n)\)</span>。<br />
启发式合并的空间复杂度取决于具体的实现方式，如果按照oi-wiki上的方法，两次遍历轻子的话，空间复杂度可以达到<span
class="math inline">\(O(n)\)</span>,如果不做这样的操作(或者这样的操作不太好实现)的话，复杂度取决于记录贡献用的容器，如果是vector作为桶的话，可能会到<span
class="math inline">\(O(n\log n)\)</span>,如果是map的话可能还<span
class="math inline">\(O(n)\)</span>。</p>
<p>下面是近期做的一些dsu on tree</p>
<h1 id="t1-nc2025winter-round5-g">T1 <a
href="https://ac.nowcoder.com/acm/contest/95337/G">NC2025winter Round5
G</a></h1>
<h3 id="题目大意">题目大意</h3>
<p>一颗树，有点权<span class="math inline">\(w\)</span>，求三元组<span
class="math inline">\((x,y,z)\)</span>数量，其中<span
class="math inline">\(x &lt; y, w_x = w_y,w_x &lt; w_z\)</span>,且<span
class="math inline">\(z\)</span>在<span
class="math inline">\(x\)</span>到<span
class="math inline">\(y\)</span>的路径上。</p>
<h3 id="分析">分析</h3>
<p>由于是求三元组，我们可以枚举节点<span
class="math inline">\(z\)</span>(这个更特殊一些)，然后计算合法的<span
class="math inline">\(x,y\)</span>对的数量。<br />
如果是暴力枚举，我们需要以每个点为根搜一遍所有子树并且统计信息，时间复杂度为<span
class="math inline">\(O(n^2)\)</span>。<br />
我们考虑使用dsu on
tree的思想得到一个较优的枚举方案，同时想出一个合适的计算贡献方案，可以利用继承重子的信息。这里我们可以随意指定一个根，下面所说子树均是以一个固定点为根的子树。<br />
统计时，我们可以用一个(unordered_)map来统计一个节点子树内权值为<span
class="math inline">\(w\)</span>的点出现了<span
class="math inline">\(c_w\)</span>次。<br />
对于一个点<span
class="math inline">\(p\)</span>，我们把<strong>以该节点为<span
class="math inline">\(z\)</span>的贡献</strong>分成两部分：<br />
1. 子树内相互贡献(点<span
class="math inline">\(p\)</span>不同子节点的子树相互贡献)<br />
2. 子树内对子树外贡献</p>
<p>这样就把这个节点的贡献不重不漏地分成两部分，且都可以根据我们维护的信息快速得出。</p>
<h3 id="子树内相互贡献">1. 子树内相互贡献</h3>
<p>对于第一部分，我们暴力合并轻子求解，算法流程如下：<br />
1. <strong>枚举子树</strong><span
class="math inline">\(map_s\)</span>内的信息<span
class="math inline">\((w,c_w)\)</span>,如果<span class="math inline">\(w
&lt; w_p\)</span>,将贡献<span class="math inline">\(c_w *
map_p[c_w]\)</span>(这里应该先count)计入该点的贡献。<br />
2. 并入子树<span class="math inline">\(map_s\)</span>内的信息。<br />
3. 对下一轻子重复1，2.</p>
<p>需要注意的是(<strong>注意节点<span
class="math inline">\(p\)</span>的子树和它的子节点的子树的区别</strong>)<br />
1.
我们不能边计算贡献边把轻子信息并入这个点。因为这样可能导致计算同一子节点的子树内的点的相互贡献，而同一子节点的子树内的点的路径不经过<span
class="math inline">\(p\)</span>。<br />
2.
我们不能先把贡献全算一遍，在来加一遍信息。这样会导致只计算了轻子树对重子树的贡献，轻子树之间的贡献没有计算。</p>
<p>这两点对于理解子树内贡献的正确性是非常重要的。</p>
<p>1，2两步的复杂度均为<span
class="math inline">\(O(size_s)\)</span>(不考虑map的常数，实际上这里使用unorder_map完全没问题)。由重链剖分的复杂度分析，这部分的复杂度为<span
class="math inline">\(O(n\log n)\)</span>。</p>
<h3 id="子树内对子树外贡献">2.子树内对子树外贡献</h3>
<p>在计算完第一部分的贡献后，我们合并了这个子树内的信息。于是可以尝试计算子树内对子树外的贡献。(不要推的时候把这部分贡献给搞漏了)<br />
我们可以先预先统计整个树上<span
class="math inline">\(w\)</span>权值的点数<span
class="math inline">\(t_s\)</span>。那么知道了子树内权值为<span
class="math inline">\(w\)</span>的点数<span
class="math inline">\(c_w\)</span>，子树外权值为<span
class="math inline">\(w\)</span>的点数就相当好得到，一个简单的容斥告诉我们为<span
class="math inline">\(t_w - c_w\)</span>。<br />
一个朴素的计算方法是，遍历这个点<span
class="math inline">\(map\)</span>上的所有权值<span
class="math inline">\((w,c_w)\)</span>,计算出贡献和<span
class="math inline">\(\sum_w c_w * (t_w - c_w) * [w &lt;
w_p]\)</span>。<br />
显然，这个是<span
class="math inline">\(O(size_p)\)</span>的，复杂度有问题。<br />
我们要求的贡献是一个类似前缀和的东西(因为大于等于<span
class="math inline">\(w_p\)</span>的都被舍去了),考虑尝试使用树状数组维护。<br />
我们考虑拆解贡献的计算式：<br />
<span class="math display">\[\sum_w c_w * (t_w - c_w) * [w &lt; w_p] =
\sum_w c_w*t_w - \sum c_w^2\]</span><br />
我们可以使用两个树状数组分别维护<span class="math inline">\(c_w*t_w
、c_w^2\)</span>,求解一个点的贡献的复杂度就是求区间和，复杂度是<span
class="math inline">\(O(\log n)\)</span>.那么第二部分的总复杂度为<span
class="math inline">\(O(n \log n)\)</span><br />
在维护树状数组对前面加入信息的影响。<br />
并入信息的单点修改时间复杂度为<span class="math inline">\(O(\log
n)\)</span>,每个点最多加入<span class="math inline">\(\log
n\)</span>次那么这部分是时间复杂度为<span class="math inline">\(O(n \log
^2 n)\)</span></p>
<h3 id="总结">总结</h3>
<p>我们通过分别计算子树内相互贡献、子树内对子树外贡献，总的时间复杂度为<span
class="math inline">\(O(n \log ^2n)\)</span></p>
<h1 id="t2-cf1681f">T2 <a
href="https://codeforces.com/contest/1681/problem/F">CF1681F</a></h1>
<p><del><em>dsu on tree
好难想，做的时候凑贡献式子wa了一上午</em></del></p>
<h3 id="题目大意-1">题目大意</h3>
<p><span class="math inline">\(n\)</span>个点的树，有边权。<br />
<span class="math inline">\(f(u,v) = u\)</span>到<span
class="math inline">\(v\)</span>的路径上仅出现一次的边权数。<br />
求<span class="math inline">\(\sum_u\sum_vf(u,v)\)</span></p>
<h3 id="分析-1">分析</h3>
<p>虽然虚树，线段树分治什么的都可以做而且思维难度我感觉远小于dsu on
tree，但是拿来练一练<span class="math inline">\(dsu on
tree\)</span>还是可以的。(<del>就是太折磨了</del>)<br />
我们要维护的信息显然就是子树内的边权集(边权出现个数)，不过计算贡献成了难题。<br />
由于我们要计算的是二元组<span
class="math inline">\((u,v)\)</span>的个数所以我们不用像上题那样算什么子树内对外，这样一是会重复，而是计算合法的<span
class="math inline">\((u,v)\)</span>个数需要一定的路径信息，这是没办法通过简单容斥得到的。<br />
由于我们是启发式合并，在确定了根的情况下，每条边<span
class="math inline">\(\{fa[u],u\}\)</span>都唯一依赖于远离根的点<span
class="math inline">\(u\)</span>，所以我们可以把边权转移到点上。<br />
先考虑合并过程中，子树内边权集的情况。<br />
1. 继承重子<span class="math inline">\(hson\)</span>，加入点权<span
class="math inline">\(val_{hson}\)</span>，计算贡献<br />
2. 合并轻子<span class="math inline">\(s\)</span>,加入点权集<span
class="math inline">\(valset_s\)</span>和<span
class="math inline">\(val_s\)</span>，计算贡献<br />
3. 递归</p>
<p>我们可以发现合并儿子时还要单独加入儿子的权值，所以不如在递归前加入自身权值(即使自身的点权不属于自己的子树内的边权集，但是贡献计算完毕了)。</p>
<p>仅维护边权集并不足以让我们有足够的信息计算出答案。我们需要维护新的信息，或者想想怎么计算贡献。</p>
<p>我们考虑两种操作分别的影响：<br />
1. 继承重子(多了一个新的边)<br />
2. 合并轻子(多了一个新的子树)</p>
<p>对于操作1，<span class="math inline">\(cover\)</span>的更新为<span
class="math inline">\(cover[w_{h}] = size(p)\)</span></p>
<p>先看操作1。<br />
我们考虑新的点<span class="math inline">\(p\)</span>到重子<span
class="math inline">\(h\)</span>内每个点的路径。重子点权为<span
class="math inline">\(w\)</span><br />
如果路径上没有相同边权，相对于原来从重子节点的路径，贡献多1。<br />
反之如果有，<strong>贡献怎么变?</strong>。<br />
仔细想想：如果路径上有1个相同边权，那么新路径和这条路径的贡献都变成0，相对于原贡献-1.这些点是什么呢？最浅层被<span
class="math inline">\(w\)</span>的点夹着的点(包括上面那个)<br />
如果路径上有2个以上的相同边权，这些贡献已经清零了，相对于原贡献不变。这些点是剩余那些。<br />
我们用<span
class="math inline">\(cover\)</span>(覆盖，很形象,可以是一个map)来记录在点权为<span
class="math inline">\(w\)</span>的子树内的点。<br />
用<span class="math inline">\(between\)</span>(中间，被<span
class="math inline">\(w\)</span>的夹着的点)来记录最浅层被<span
class="math inline">\(w\)</span>的点夹着的点(包括上面那个)的个数。<br />
计从子树根出发的到子树内点的总贡献为<span
class="math inline">\(val\)</span><br />
贡献多-1的点数为<span
class="math inline">\(between\)</span>，贡献多0的点数为<span
class="math inline">\(cover[w] -
between[w]\)</span>,贡献多1的点数为<span class="math inline">\(size -
cover[w]\)</span><br />
那么，继承重子的贡献为:<span class="math inline">\(val[h] + size[h] -
cover[w] - between[w]\)</span><br />
我们不如在递归下一层前，用上式更新自己的<span
class="math inline">\(val\)</span>，所以新的<span
class="math inline">\(val\)</span>定义为添加一个不冲突的点，应该加上的贡献。</p>
<p>对于操作2，我们要求合并一个轻子<span
class="math inline">\(s\)</span>多出来的贡献。<br />
首先由于我们要确保时间复杂度正确，我们只能枚举轻子的信息。<br />
考虑将新的路径拆成2部分，一部分是在重子(包括已经合并完了的轻子)的路径，一部分是轻子那边的路径。<br />
对于重子那边的路径，相当于加了<span
class="math inline">\(sz_s\)</span>个点(先不考虑边权问题)，贡献为<span
class="math inline">\(val_p*size_s\)</span>,同理轻子那边的贡献为<span
class="math inline">\(val_s*size_p\)</span>。<br />
再考虑冲突问题，哪些点会产生冲突减少贡献呢？<br />
考虑一个轻子里(对)<span
class="math inline">\(between[w]\)</span>(有贡献)的点，路径上带有一个<span
class="math inline">\(w\)</span>，如果在重子那边遇到一个<span
class="math inline">\(cover[w]\)</span>的点，路径上就有2个<span
class="math inline">\(w\)</span>，所以在减去轻子这边多算的贡献时应该减去<span
class="math inline">\(\sum_w between_s[w] \times cover_p
[w]\)</span>。<br />
我们<strong>对偶地</strong>考虑，那么为了减去重子那边多算的贡献，我们减去<span
class="math inline">\(\sum_w cover_s [w] \times
between_p[w]\)</span><br />
(我们<strong>只考虑边<span
class="math inline">\(between\)</span>的点的损失</strong>，这样就不重不漏)</p>
<p>最后我们考虑加点更新信息。<br />
首先目前我们加点(实际上是加边)，首先是加入其他子树，最后才是加入自身。(想一想边集变化，上面也有解释)。<br />
操作2的影响是很直接的，<span class="math inline">\(cover\)</span>和<span
class="math inline">\(between\)</span>直接按点值加就行，没有相互作用。<br />
操作完后加入自身，<span class="math inline">\(cover[w_p] = size[p],
between[p] = cover[p] - precover[w_p]\)</span>，所以我们先修改<span
class="math inline">\(between\)</span>,再修改<span
class="math inline">\(cover\)</span>。</p>
<p>再理一下算法流程：<br />
1. 继承重子，加上贡献<span class="math inline">\(val[p]\)</span><br />
2. 遍历轻子并且合并，加上贡献<br />
3. 加入自身，修改自身的<span class="math inline">\(val 、cover
、between\)</span></p>
<p>考虑map的复杂度，时间复杂度为<span class="math inline">\(O(n \log^2
n)\)</span>。<br />
以下是我变量命名一塌糊涂的代码<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> edge = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;edge&gt;&gt;<span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        g[u].<span class="built_in">emplace_back</span>(v, w);</span><br><span class="line">        g[v].<span class="built_in">emplace_back</span>(u, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">fa</span>(n + <span class="number">1</span>, <span class="number">-1</span>), <span class="built_in">hson</span>(n + <span class="number">1</span>, <span class="number">-1</span>), <span class="built_in">sz</span>(n + <span class="number">1</span>, <span class="number">1</span>), <span class="built_in">w</span>(n + <span class="number">1</span>);</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt;dfs = [&amp;](<span class="type">int</span> p)-&gt;<span class="type">void</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [s, wi] : g[p]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s != fa[p]) &#123;</span><br><span class="line">                    fa[s] = p;</span><br><span class="line">                    w[s] = wi;</span><br><span class="line">                    <span class="built_in">dfs</span>(s);</span><br><span class="line">                    sz[p] += sz[s];</span><br><span class="line">                    <span class="keyword">if</span> (hson[p] == <span class="number">-1</span> || sz[hson[p]] &lt; sz[s]) &#123;</span><br><span class="line">                        hson[p] = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt2</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">val</span>(n + <span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">newsz</span>(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge = [&amp;](<span class="type">int</span> fa, <span class="type">int</span> p)</span><br><span class="line">        &#123;</span><br><span class="line">            val[fa] += val[p];</span><br><span class="line">            newsz[fa] += newsz[p];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mp : \sum dep*cnt  cnt: 覆盖点数</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>, map&lt;<span class="type">int</span>, ll&gt;&amp; cnt, map&lt;<span class="type">int</span>, ll&gt;&amp; cnt2)&gt;dsu = [&amp;](<span class="type">int</span> p, map&lt;<span class="type">int</span>, ll&gt;&amp; cnt, map&lt;<span class="type">int</span>,ll&gt;&amp;cnt2 )-&gt;<span class="type">void</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hson[p] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">dsu</span>(hson[p], cnt, cnt2);</span><br><span class="line">                <span class="comment">//合并hson</span></span><br><span class="line">                ans += val[hson[p]];</span><br><span class="line">                <span class="built_in">merge</span>(p, hson[p]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [s, w] : g[p]) &#123;</span><br><span class="line">                    map&lt;<span class="type">int</span>, ll&gt;tmp2,tmp3;</span><br><span class="line">                    <span class="keyword">if</span> (s != hson[p] &amp;&amp; s != fa[p]) &#123;</span><br><span class="line">                        <span class="built_in">dsu</span>(s,tmp2, tmp3);</span><br><span class="line">                        ans += val[p] * newsz[s] + val[s] * newsz[p];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//p to lson</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [v, c] : tmp3) &#123;</span><br><span class="line">                            ans -= c * cnt[v];</span><br><span class="line">                            <span class="comment">//mp[v] += c;</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//lson to p</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [v, c] : tmp2) &#123;</span><br><span class="line">                            ans -= c * cnt2[v];</span><br><span class="line">                            cnt[v] += c;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [v, c] : tmp3) &#123;</span><br><span class="line">                            <span class="comment">//ans -= c * mp[v];</span></span><br><span class="line">                            cnt2[v] += c;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">merge</span>(p, s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//add p self</span></span><br><span class="line">            val[p] += sz[p];</span><br><span class="line">            val[p] -= cnt[w[p]] + cnt2[w[p]];</span><br><span class="line">            </span><br><span class="line">            cnt2[w[p]] = sz[p] - cnt[w[p]];</span><br><span class="line">            cnt[w[p]] = sz[p];</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    map&lt;<span class="type">int</span>, ll&gt;tmp,tmp2,tmp3;</span><br><span class="line">    <span class="function">mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    <span class="type">int</span> root = <span class="built_in">rng</span>() % n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//root = 1;</span></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    <span class="built_in">dsu</span>(root,tmp2, tmp3);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <del>这题用dsu on
tree,做题感觉赤了一遍史，写题解又赤了一遍。</del></p>
<h1 id="小结">小结</h1>
<p>dsu on tree很好解决这种树上的点对、三元组的问题。<br />
如果是点对的话，可以只考虑子树内合法的点对。<br />
如果是三元组的话，可以考虑dfs到某个点时，以这个点作为三元组的一个，另外两个点在子树内/子树内加子树外的情况。这样就可以不重不漏了。</p>
<p><em>ps : 以后要是遇到别的用dsu on tree的题，或许会更新</em></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>Xor on permutation</title>
    <url>/2025/03/20/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/Xor%20on%20permutation/</url>
    <content><![CDATA[<h1 id="作用在排列上的异或运算">作用在排列上的异或运算</h1>
<p><em>也不知道这一部分放在哪个类别下比较好,姑且放在数论下面了</em></p>
<h2 id="前置知识">前置知识</h2>
<p>排列和置换</p>
<h2 id="引入">引入</h2>
<p>偶尔在做算法题的时候会遇到需要研究一个区间的数都异或上一个数之后，这个区间的数的情况(这里情况指各种各样的性质)。不过我们可以把任意区间<span
class="math inline">\([l,r]\)</span>转化成两个排列<span
class="math inline">\(P_{r},P_{l-1}\)</span>的差。所以我们试图借助几个例题来研究排列异或一个数之后具有的性质。
以下是3个例题：<br />
<a href="https://codeforces.com/contest/1979/problem/B">CF1979B XOR
Sequences</a><br />
<a href="https://codeforces.com/contest/2075/problem/E">CF2075E XOR
Matrix</a><br />
<a
href="https://codeforces.com/group/BJlsDCvlJO/contest/586547/problem/H">CF
Group:0x3f vp Group FireflyCup H Simple XOR Problem</a></p>
<h2 id="分析">分析</h2>
<p>我们考虑一个无穷序列<span
class="math inline">\(0,1,2,...\)</span>异或上一个数<span
class="math inline">\(x\)</span>的情况。<br />
显然，我们应该把<span
class="math inline">\(x\)</span>拆成不同二进制位来分析，或者说异或<span
class="math inline">\(x\)</span>的效果实际上是异或上<span
class="math inline">\(x\)</span>不同二进制位的效果的叠加。<br />
于是我们可以转而分析异或<span
class="math inline">\(2\)</span>的自然数次幂的作用。<br />
1. 如果<span class="math inline">\(xor 1\)</span>,序列变成<span
class="math inline">\(1,0,3,2,5,4,...\)</span>,相当于把相邻两位做一个对换。<br />
2. 如果<span class="math inline">\(xor 2\)</span>,序列变成<span
class="math inline">\(2,3,0,1,6,7,4,5,...\)</span>相当于相邻2位一组，把相邻两组做一个对换。<br />
3. 如果<span class="math inline">\(xor
2^k\)</span>,可以类比推得：相当于每<span
class="math inline">\(2^k\)</span>一组，顺次把每两组做一个对换。<br />
可以发现，<span class="math inline">\(xor
2^k\)</span>的影响区间是一段一段的(只有段内的对换，段之间没有对换)，每段之间没有干涉，段长是<span
class="math inline">\(2^{k+1}\)</span>。我们可以先来看看段内之间的作用。<br />
实际上段内的作用简单：<span class="math inline">\(xor
k\)</span>的作用即为把一段的前半部分和后半部分对换，每半部分内部的顺序保持不变。<br />
如果用置换的语言来描述的话，就是：<br />
<span class="math display">\[Xor 2^k = \sum_{i = 0}^{\infty} \sigma_k(i)
,\\ \sigma_k(i) = \begin{pmatrix}
i \cdot 2^{k+1} + 0   &amp; i \cdot 2^{k+1} + 1     &amp; i \cdot
2^{k+1} + 2     &amp; ... &amp; i \cdot 2^{k+1} + 2^k - 1 &amp; ...
&amp; i \cdot 2^{k+1} + 2^{k+1} - 1\\
i \cdot 2^{ k+1} + 2^k &amp; i \cdot 2^{k+1} + 2^k+1 &amp; i \cdot
2^{k+1} +2^k +2 &amp;  ... &amp; i \cdot 2^{k+1} + 2^{k+1} - 1 &amp; ...
&amp;i \cdot 2^{k+1} + 2^k - 1
\end{pmatrix}\]</span><br />
而且实际上这是一个自然数集上的<strong>双射</strong>。</p>
<p>我们考虑其中一个平凡的置换在有限排列上的作用，即<br />
<span class="math display">\[\sigma_k = \begin{pmatrix}
0   &amp; 1     &amp; 2     &amp; ... &amp; 2^k - 1   &amp; 2^k &amp;
... &amp; 2^{k+1} - 1\\
2^k &amp; 2^k+1 &amp; +2^k +2 &amp;  ... &amp; 2^{k+1} - 1  &amp; 0
&amp;...&amp; 2^k - 1
\end{pmatrix}\]</span></p>
<ol type="1">
<li>如果排列长度<span class="math inline">\(n \geq
2^{k+1}-1\)</span>,那么会对这个排列的前面这一段做一个对半的对换，作用后这一段在值域上仍保持连续。<br />
</li>
<li>如果排列长度<span class="math inline">\(n
&lt;  2^{k+1}-1\)</span>,具体情况还可以再分类讨论：
<ol type="1">
<li>如果<span class="math inline">\(n \leq
2^{k}-1\)</span>,那么这个排列将整体加上<span
class="math inline">\(2^k\)</span>。<br />
</li>
<li>如果<span class="math inline">\(n \geq
2^k\)</span>,那么这个排列被作用后，值域上变成不连续的两部分,其中一部分<span
class="math inline">\(length \leq 2^{k}-1\)</span>,一部分<span
class="math inline">\(n =  2^{k}-1\)</span>。</li>
</ol></li>
</ol>
<p>根据我们前面的分析，我们可以得到一些推论，用于解决以上给出的3个例题。</p>
<ol type="1">
<li>对于一个区间<span
class="math inline">\([l,r]\)</span>,它异或上一个数<span
class="math inline">\(x\)</span>后，在值域上最多形成<span
class="math inline">\(O(\log x)\)</span>个连续区间<br />
&gt;<span class="math inline">\(Proof\)</span>：<br />
我们从高位到低位去考虑异或一个数的影响。<br />
根据我们前面所做的讨论，对于<span
class="math inline">\(x\)</span>的最高位，一个连续区间最多只有左右两端的部分(块长不足<span
class="math inline">\(2^{k+1}-1\)</span>,即情况2)会被"切割"开。<br />
考虑其中被切割出来的一块(不妨设为右边那块)，它的左端点原来为<span
class="math inline">\(i \cdot 2^{k+1}\)</span>,被置换到了<span
class="math inline">\((i + 1) \cdot 2^{k + 1} -
1\)</span>作为右端点。那么对于次高位，一定是不能从这一块的右端"切割"出一块的。<br />
递归地考虑：除了最高位，每一位最多可以在上一位切割出来的新块上多切割出一块(因为被切出来的新块已经对齐一端了)。<br />
那么实际上最多切割出<span class="math inline">\(2 \log
x\)</span>块。而且平均值是小于<span class="math inline">\(\log
x\)</span>的。<br />
&gt; 这里有一个可以用来直观感受一下的代码：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mt19937 <span class="title">g</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> inf = <span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">g</span>() % inf, r = <span class="built_in">g</span>() % inf;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)<span class="built_in">swap</span>(l, r);</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">g</span>() % inf;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">1</span> &lt;&lt; <span class="number">21</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        a[i ^ x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;ranges;</span><br><span class="line">    <span class="type">int</span> in = <span class="number">0</span>;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;pr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in) &#123;</span><br><span class="line">                in = <span class="literal">false</span>;</span><br><span class="line">                ranges.<span class="built_in">push_back</span>(pr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in)</span><br><span class="line">                pr.second = i;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                in = <span class="literal">true</span>;</span><br><span class="line">                pr.first = i;</span><br><span class="line">                pr.second = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l : &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; r : &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot; x : &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ranges cnt : &quot;</span> &lt;&lt; ranges.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [l, r] : ranges) &#123;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于一个排列<span class="math inline">\(P_n\)</span>,记异或上<span
class="math inline">\(x\)</span>之后,小于等于<span
class="math inline">\(n\)</span>的数的个数为<span
class="math inline">\(f_n(x)\)</span>。<br />
有：
<ol type="1">
<li><span class="math inline">\(f_n(x) = f_n(y) \quad\quad   if \quad
highbit(x) = highbit(y)\)</span></li>
<li><span class="math inline">\(f_n(x) \leq f_n(y) \quad\quad if \quad
highbit(x) &gt; highbit(y)\)</span> &gt;<span
class="math inline">\(Proof\)</span>:<br />
对第一条，<span class="math inline">\(x,y\)</span>最高位<span
class="math inline">\(2^k\)</span>的影响是相同的。仅考虑最高位影响，显然只有最右端的置换<span
class="math inline">\(\sigma_k(\left\lfloor\frac{n}{2^{k+1}}\right\rfloor)\)</span>会影响答案。<br />
考虑前面我们讨论过的<span
class="math inline">\(\sigma_k\)</span>作用在<span
class="math inline">\(P_n\)</span>的情况(这里的<span
class="math inline">\(n\)</span>和前面的不一样了)，如果是<span
class="math inline">\(n &lt;2^k\)</span>，这一段被全部换到大于等于<span
class="math inline">\(2^k\)</span>的位置，不管低位的置换作用是什么样子，这一段都会一直大于等于<span
class="math inline">\(2^k\)</span>,贡献为0。<br />
如果是<span class="math inline">\(n \leq 2^k\)</span>,会有<span
class="math inline">\(n - 2^k + 1\)</span>个大于等于<span
class="math inline">\(2^k\)</span>的数被换到左边。具有贡献，同时小于<span
class="math inline">\(2^k\)</span>的数占满了大于等于<span
class="math inline">\(2^k\)</span>的位置，其中<span
class="math inline">\(n - 2^k +
1\)</span>个位置有贡献。而无论低位的等效置换怎么换，产生的贡献是不变的。<br />
所以<span class="math inline">\(f_n(x)\)</span>的值仅和<span
class="math inline">\(x\)</span>的<span
class="math inline">\(highbit\)</span>有关。<br />
对于第二条，正向不太好说。但是我们可以逆向理解贡献的计算：<span
class="math inline">\(n\)</span>减去被换到<span
class="math inline">\(0\sim n\)</span>区域的大于<span
class="math inline">\(n\)</span>的数。而我们可以观察到：高位越大，最右端的置换包含的超出<span
class="math inline">\(n\)</span>的部分是不减的。可以比较直观地感受到第二条。(严谨一些的解释的话情况比较多，写起来有点麻烦(<del>好吧就是我懒了</del>))。<br />
&gt; 下面来看看上面提到的3个题。</li>
</ol></li>
</ol>
<h2 id="t1-cf1979b-xor-sequences">T1 <a
href="https://codeforces.com/contest/1979/problem/B">CF1979B XOR
Sequences</a></h2>
<p>一道简单的div2B 猜猜题。<br />
题意大概是<span class="math inline">\(P_{\infty}\)</span>分别异或<span
class="math inline">\(x,y\)</span>得到<span
class="math inline">\(a,b\)</span>,求<span
class="math inline">\(a,b\)</span>的最长公共子段(LCS)。<br />
我们从置换叠加的角度去分析：<br />
如果<span class="math inline">\(a\)</span>有<span
class="math inline">\(\sigma_k\)</span>作用而<span
class="math inline">\(b\)</span>没有，那么LCS最多长<span
class="math inline">\(2^k\)</span>。<br />
所以实际上我们是在找<span
class="math inline">\(x,y\)</span>从低到高第一个不同的二进制位。<br />
如果是第k位，那么答案为<span class="math inline">\(2^k\)</span>。</p>
<h2 id="t2-cf2075e-xor-matrix">T2 <a
href="https://codeforces.com/contest/2075/problem/E">CF2075E XOR
Matrix</a></h2>
<p>div2E 思维题？<br />
题意是在<span class="math inline">\(n\)</span>行<span
class="math inline">\(m\)</span>列的矩阵的行和列上填上一些数，行，列的值域分别为<span
class="math inline">\([0,x],[0,y]\)</span>。矩阵<span
class="math inline">\(a_{ij}\)</span>的值为<span
class="math inline">\(r_i \oplus
c_j\)</span>。要求矩阵的值最多只有2种，问合法的填法数目。<br />
首先，一行/列最多出现2种不同的值，因为异或是一个双射，3种不同值一定有3种结果，此时是不合法的。<br />
于是我们可以分讨一下：<br />
用<span class="math inline">\(a +
b\)</span>表示我们行和列选几个不同的数。<br />
1. <span class="math inline">\(1+1\)</span>,此时很简单，一共<span
class="math inline">\((x+1)(y+1)\)</span>种填法。<br />
2. <span class="math inline">\(1+2 /
2+1\)</span>。任意选2个数填充行/列即可，这里需要考虑2种数的填法，减去退化成<span
class="math inline">\(1+1\)</span>的情况。<br />
一共<span class="math inline">\(\tbinom{x+1}{2}*(2^n - 2)*(y+1) +
\tbinom{y+1}{2}*(2^m - 2)*(x+1)\)</span>种填法<br />
3. <span
class="math inline">\(2+2\)</span>此时比较复杂。我们先考虑什么时候是合法的：4个数的异或只有2种结果。实际上，我们可以选择行填充<span
class="math inline">\(\{i,i\oplus k\}\)</span>,列填充<span
class="math inline">\(\{j ,j \oplus k\}\)</span>,那么结果只有<span
class="math inline">\(i\oplus j, i\oplus j\oplus
k\)</span>两种，符合题意。其次我们考虑这形如这样的构造是否遍历到了所有的合法构造方法。实际上答案是肯定的。（这里可以仔细思考一下为什么）<br />
不过这里我们<span
class="math inline">\(k\)</span>从1开始取，不然就退化了。<br />
然后就是对于每个<span class="math inline">\(k\)</span>，找出合法的<span
class="math inline">\(i,j\)</span>的数目(为了避免重复，每对<span
class="math inline">\(\{i,i \oplus k\}\)</span>只算一个)，即<span
class="math inline">\(i &lt; i\oplus k\leq n\)</span>,<span
class="math inline">\(j\)</span>类似。暴力肯定是不可取的。根据我们前面的推论，实际上每个对于<span
class="math inline">\(highbit\)</span>相等的<span
class="math inline">\(k\)</span>，这个值是相等的。于是我们可以枚举<span
class="math inline">\(k = 2^r\)</span>的情况，每次一起计算<span
class="math inline">\(highbit\)</span>相同的<span
class="math inline">\(k\)</span>的答案即可。</p>
<p>代码如下<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">power</span><span class="params">(T a, i64 b)</span> </span>&#123;</span><br><span class="line">    T res&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> i64 <span class="title">mul</span><span class="params">(i64 a, i64 b, i64 p)</span> </span>&#123;</span><br><span class="line">    i64 res = a * b - <span class="built_in">i64</span>(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;i64 P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MInt</span> &#123;</span><br><span class="line">    i64 x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">()</span> : x&#123;</span> <span class="number">0</span> &#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">(i64 x)</span> : x&#123;</span> <span class="built_in">norm</span>(x % <span class="built_in">getMod</span>()) &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> i64 Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> i64 <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(i64 Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">norm</span><span class="params">(i64 x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> i64 <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MInt res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>*=(MInt rhs)&amp; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getMod</span>() &lt; (<span class="number">1ULL</span> &lt;&lt; <span class="number">31</span>)) &#123;</span><br><span class="line">            x = x * rhs.x % <span class="built_in">int</span>(<span class="built_in">getMod</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x = <span class="built_in">mul</span>(x, rhs.x, <span class="built_in">getMod</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>+=(MInt rhs)&amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>-=(MInt rhs)&amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt&amp; <span class="keyword">operator</span>/=(MInt rhs)&amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>*(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>+(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>/(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, MInt&amp; a) &#123;</span><br><span class="line">        i64 v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MInt&amp; a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() &lt; rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">i64 MInt&lt;<span class="number">0</span>&gt;::Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="comment">//i64 MInt&lt;0&gt;::Mod = 1000000007;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Z = MInt&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">cntx</span>(<span class="number">30</span>), <span class="built_in">cnty</span>(<span class="number">30</span>);</span><br><span class="line">    Z ans = <span class="number">0</span>;</span><br><span class="line">    ll np = <span class="built_in">qpow</span>(<span class="number">2</span>, n), mp = <span class="built_in">qpow</span>(<span class="number">2</span>, m);</span><br><span class="line">    <span class="comment">//1+1</span></span><br><span class="line">    ans += <span class="built_in">Z</span>(<span class="number">1</span>) * (x + <span class="number">1</span>) * (y + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//1+2</span></span><br><span class="line">    ans += <span class="built_in">Z</span>(<span class="number">1</span>)*x * (x + <span class="number">1</span>) / <span class="number">2</span> * (np - <span class="number">2</span>) * (y + <span class="number">1</span>);</span><br><span class="line">    ans += <span class="built_in">Z</span>(<span class="number">1</span>)*y * (y + <span class="number">1</span>) / <span class="number">2</span> * (mp - <span class="number">2</span>) * (x + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//2+2</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//(i,i^k)*(j,j^k)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        uint bitmask = ((<span class="number">1u</span> &lt;&lt; i + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">        cntx[i] = (x &amp; ~bitmask) / <span class="number">2</span>;</span><br><span class="line">        cnty[i] = (y &amp; ~bitmask) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span>)cntx[i] += (x &amp; bitmask &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &gt;&gt; i &amp; <span class="number">1</span>)cnty[i] += (y &amp; bitmask &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;<span class="comment">//comb * ok i * ok j * ok k</span></span><br><span class="line">        ans += <span class="built_in">Z</span>(<span class="number">1</span>)*(np - <span class="number">2</span>) * (mp - <span class="number">2</span>) * cntx[i]*cnty[i]*(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="t3-cf-group0x3f-vp-group-fireflycup-h-simple-xor-problem">T3 <a
href="https://codeforces.com/group/BJlsDCvlJO/contest/586547/problem/H">CF
Group:0x3f vp Group FireflyCup H Simple XOR Problem</a></h2>
<p>打群友办的比赛碰到的题，也是让我想起来之前的一些想法，最终想出来异或将一个区间划分成<span
class="math inline">\(\log\)</span>个区间的题。但是这题卡常，太坏了！<br />
题意:求和<br />
<span class="math display">\[
\sum_{x=l}^{r}\left(x\oplus y\right)^k\pmod{(10^{9}+7)}
\]</span> 其中<span class="math inline">\(l\)</span>, <span
class="math inline">\(r\)</span>, <span
class="math inline">\(y\)</span>, and <span
class="math inline">\(k\)</span> (<span class="math inline">\(1\le l\le
r\le 10^9\)</span>, <span class="math inline">\(1\le y\le 10^9\)</span>,
<span class="math inline">\(1\le k\le 10^6\)</span>).<br />
我们需要一些预备知识和技巧：<br />
对于<span class="math inline">\([l,r]\)</span>上的求和，可以转化成<span
class="math inline">\([0,r]\)</span>上的求和减去<span
class="math inline">\([0,l-1]\)</span>上的求和。<br />
自然数的<span class="math inline">\(k\)</span>次幂之和是一个<span
class="math inline">\(k+1\)</span>次多项式，这个可以用lagrange插值法在最快<span
class="math inline">\(O(n \log^2 n)\)</span>的复杂度下搞出来。<br />
根据我们前面的推论，我们可以把异或后的值域划分成最多<span
class="math inline">\(log
y\)</span>个连续区间，每个连续区间的贡献我们用自然数<span
class="math inline">\(k\)</span>次幂和公式求出来。形如<span
class="math inline">\([l,r]\)</span>的区间在异或下的端点可能不太好维护，我们可以转成<span
class="math inline">\([1,r]\)</span>这样的区间来解决，这样的区间是好维护的。<br />
最后的复杂度：插值<span class="math inline">\(O(k \log^2 k)\)</span> +
区间求和<span class="math inline">\(O(k\log y)\)</span>。<br />
实现代码：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll pre[N], suf[N], finv[N], fact[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)res = res * a % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        fact[i] = fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    finv[N - <span class="number">1</span>] = <span class="built_in">qmi</span>(fact[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        finv[i - <span class="number">1</span>] = finv[i] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(ll* f, <span class="type">int</span> mx, ll n)</span><span class="comment">//已知f[0]到f[mx] 求f[n]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= mx)<span class="keyword">return</span> f[n];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    pre[<span class="number">0</span>] = suf[mx] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= mx; ++i)</span><br><span class="line">        pre[i] = <span class="number">1ll</span> * (n - i + <span class="number">1</span>) % mod * pre[i - <span class="number">1</span>] % mod;<span class="comment">//注意到(n-i+1)*pre[i-1]在有些题可能爆ll 先%</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mx; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        suf[i - <span class="number">1</span>] = <span class="number">1ll</span> * (n - i) % mod * suf[i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= mx; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sg = (mx - i) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        ans = ans + <span class="number">1ll</span> * sg * pre[i] % mod * suf[i] % mod * finv[i] % mod * finv[mx - i] % mod * f[i] % mod;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= mod)ans -= mod;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>)ans += mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l, r, y, k;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l)<span class="keyword">return</span> (<span class="built_in">cal</span>(g, k + <span class="number">1</span>, r) - <span class="built_in">cal</span>(g, k + <span class="number">1</span>, l - <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">cal</span>(g, k + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> a = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> b = y &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> lq = l + (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="type">int</span> rq = l + (<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">            res = (res + <span class="built_in">ask</span>(lq, rq)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">1</span>)l += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> lq = l;</span><br><span class="line">            <span class="type">int</span> rq = l + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>;</span><br><span class="line">            res = (res + <span class="built_in">ask</span>(lq, rq)) % mod;</span><br><span class="line">            l += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res + <span class="built_in">ask</span>(l, l)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; y &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        g[i] = (<span class="built_in">qmi</span>(i, k) + g[i - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll res = (<span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>)) % mod;</span><br><span class="line">    cout &lt;&lt; (res + mod) % mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>Möbius inversion, Möbius transformation and Inclusion-Exclusion on Posets</title>
    <url>/2025/03/24/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/M%C3%B6bius%20inversion,%20M%C3%B6bius%20transformation%20and%20Inclusion-Exclusion%20on%20Posets/</url>
    <content><![CDATA[<h1
id="möbius-inversion-möbius-transformation-and-inclusion-exclusion-on-posets">Möbius
inversion, Möbius transformation and Inclusion-Exclusion on Posets</h1>
<h2 id="pre">pre</h2>
<p>在算法竞赛中，Möbius反演主要出现在:一类推式子题用于数论分块优化/偏序集上的容斥/求解积性函数和Dirichlet卷积相关问题。而Möbius变换经常是解决位运算卷积之类的问题。<br />
这篇blog主要用于梳理数论上这Möbius反演这及一些前置的知识，进一步的运用，以及Möbius变换的部分内涵，两种操作之间的联系。以及一些习题和其中的trick。</p>
<h1 id="part-1.-möbius-inversion">Part 1. Möbius inversion</h1>
<h2 id="前置知识">前置知识</h2>
<h3 id="积性函数">1. 积性函数</h3>
<p>在数论中，算术函数（或称数论函数）指定义域为正整数、陪域为复数的函数，每个算术函数都可视为复数的序列。<br />
<em>这篇blog讨论的所有函数都是数论函数</em><br />
积性函数：<br />
如果一个函数<span class="math inline">\(f\)</span>具有性质<span
class="math inline">\(\forall( a,b,\gcd(a,b) = 1), f(ab) =
f(a)f(b)\)</span>，那么就称这个函数是积性函数。<br />
如果一个函数<span class="math inline">\(f\)</span>具有性质<span
class="math inline">\(\forall(a,b),f(ab) =
f(a)f(b)\)</span>,那么称这个函数为完全积性函数。<br />
一下是一些例子：<br />
<span class="math inline">\(I，I(x) = 1\)</span> ，常数函数。<br />
<span class="math inline">\(id_k,id(x) = x^k\)</span> ，幂函数，<span
class="math inline">\(id = id_1\)</span>即恒等函数。<br />
<span class="math inline">\(\epsilon,\epsilon(x) = [x == 1]\)</span>
,单位函数。<br />
<span class="math inline">\(\sigma_k,\sigma_k(x) = \sum_{d|x}
d^k\)</span> ,约数幂函数<br />
<span class="math inline">\(d = \tau = \sigma_0\)</span> ,除数函数<br />
<span class="math inline">\(\phi ,\phi(x) = \sum_{a \nmid x}1\)</span>
,欧拉函数<br />
积性函数的特点是可以通过质数幂处的函数值快速得到任意位置的函数值。<br />
几乎所有积性函数都可以通过欧拉筛线性求解<span
class="math inline">\([1,n]\)</span>的函数值(通过枚举每个数的最小质因子实现转移)。</p>
<h3 id="dirichlet卷积">2. Dirichlet卷积</h3>
<p>定义两个函数的Dirichlet卷积为：<br />
<span class="math display">\[ (f * g)(n) =
\sum_{d|n}f(d)g(\frac{n}{d})\]</span><br />
Dirichlet卷积有如下性质：<br />
1. 交换律 <span class="math inline">\(f*g = g*f\)</span><br />
2. 结合律 <span class="math inline">\((f*g)*h = f*(g*h)\)</span><br />
3. 分配律 <span class="math inline">\((f + g)*h = f*h +
g*h\)</span><br />
4. 消去律 <span class="math inline">\(f = g \Leftrightarrow f*h =
g*h\)</span>，其中<span class="math inline">\(h(1) \neq 0\)</span><br />
5. 单位元 <span class="math inline">\(f * \epsilon = f\)</span><br />
6. 逆元 <span class="math inline">\(f * g = \epsilon\)</span>，<span
class="math inline">\(f,g\)</span>互为逆元，逆元唯一，用<span
class="math inline">\(f^{-1}\)</span>表示。<br />
7. <span class="math inline">\(f,g\)</span>是积性函数，那么<span
class="math inline">\(h = f*g\)</span>也是积性函数。<br />
<em>证明可以证<span
class="math inline">\(h(ab)=h(a)h(b)\)</span></em><br />
8. <span class="math inline">\(f\)</span>是积性函数，那么<span
class="math inline">\(f^{-1}\)</span>是积性函数。<br />
9. 和函数<span class="math inline">\(F = f*I ,F(n)
=  \sum_{d|n}f(d)\)</span><br />
10. 由前面的推论，全体积性函数和Dirichlet卷积构成一个阿贝尔群<span
class="math inline">\((G,*)\)</span>，单位元是<span
class="math inline">\(\epsilon\)</span>。</p>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p>首先引入莫比乌斯函数。<br />
莫比乌斯函数是Dirichlet卷积意义下 <span class="math inline">\(I\)</span>
的逆元。<br />
有：<br />
<span class="math display">\[\begin{align*}
\mu(n)=\left\{
   \begin{array}{ll}
      1&amp;n=1\\
      0&amp;\exists p,p^2 | n\\
      (-1)^k&amp;n = p_1^{\alpha_1}p_2^{\alpha_2}...p_k^{\alpha_k}\\
   \end{array}
   \right.
\end{align*}\]</span></p>
<p>由前面给出的和函数的定义，我们有：<br />
<span class="math display">\[F = f * I \Leftrightarrow f = \mu *
F\]</span><br />
实际上，由 <span class="math inline">\(f\)</span> 得到 <span
class="math inline">\(F\)</span>
是整除偏序上的zeta变换，而我们反过来，利用<span
class="math inline">\(\mu\)</span>由 <span
class="math inline">\(F\)</span> 得到 <span
class="math inline">\(f\)</span>
的过程称为莫比乌斯反演，这是莫比乌斯变换在整除偏序上的运用。<br />
莫比乌斯反演公式：<br />
<span class="math display">\[ f(n) = \sum_{d | n}
F(d)\mu(\frac{n}{d})\]</span><br />
莫比乌斯反演可以用于计算一些和整除偏序相关的容斥问题，和一些转化式子为更容易快速求值/预处理多次回答询问的问题。<br />
以下是一些有关的式子和结论，常见于这些题目中。<br />
1. <span class="math inline">\(\mu*I = \epsilon ,\sum_{d|n} \mu(d) =
1\)</span><br />
常用于<span class="math inline">\([\gcd(i,j) = 1] = \sum_{d|\gcd(i,j)}
\mu(d) = \sum_{d|i,d|j}\mu(d)\)</span>.<br />
2. <span class="math inline">\(\phi*I = id\)</span><br />
常用于<span class="math inline">\(gcd(i,j) = \sum_{d|\gcd(i,j)}\phi(d) =
\sum_{d|i,d|j}\phi(d)\)</span>，即<span
class="math inline">\(\gcd\)</span>拆解为<span
class="math inline">\(\phi\)</span>卷积。<br />
3. <span class="math inline">\(id_k * I = \sigma_k \Leftrightarrow \mu *
\sigma_k = id_k\)</span><br />
4. <span class="math inline">\(\sum_{i = 1}^{n} d(i) = \sum_{k =
1}^{n}  \left\lfloor\frac{n}{k}\right\rfloor\)</span><br />
这是对<span
class="math inline">\(d\)</span>的单点前缀和函数值的两种计算方法，前者可以线性预处理<span
class="math inline">\([1,n]\)</span>,后者则可以利用整除分块加速<span
class="math inline">\(O(\sqrt n)\)</span>单点求值。<br />
5. <span class="math inline">\(id_k(n)\)</span>有<span
class="math inline">\(O(n)\)</span>欧拉筛预处理，<span
class="math inline">\(O(1)\)</span>单次询问的算法，也有Lagrange插值<span
class="math inline">\(O(k\log^2 k)\)</span>预处理，<span
class="math inline">\(O(k)\)</span>单次询问的单点求值法。要根据实际需要(值域，询问次数等等)来分析用哪一种比较好。<br />
这种可以利用特殊方法加速点值求解的积性函数其实都要注意这一点。</p>
<h1 id="part-2.-möbius-transformation">Part 2. Möbius
transformation</h1>
<p>根据网上搜集的一些资料，我更倾向于用集合论和偏序集(poset)的语言来描述莫比乌斯变换。</p>
<h2 id="zeta-变换">1. Zeta 变换</h2>
<p>对于定义在偏序集<span
class="math inline">\((P,\leq)\)</span>上的函数<span
class="math inline">\(f : P \rightarrow \mathbb{C}\)</span> , <span
class="math inline">\(\mathcal{F}(P)\)</span>是定义在<span
class="math inline">\(P\)</span>上的全体函数的集合.<br />
Zeta变换 <span class="math inline">\(\zeta : \mathcal{F}(P) \rightarrow
\mathcal{F}(P)\)</span> 定义为：<br />
<span class="math display">\[(\zeta f)(x) = \sum_{y \leq
x}f(y)\]</span><br />
或者使用Zeta函数表述<br />
<span class="math display">\[(\zeta f)(x) = \sum_{y \leq
x}\zeta(y,x)f(y)\]</span><br />
其中Zeta函数为：<br />
<span class="math display">\[\begin{align*}
\zeta(y,x)=
\begin{cases}
1&amp;y \leq x\\
0&amp; otherwise\\
\end{cases}
\end{align*}\]</span> (需要注意的是偏序集如果不是全序集，<span
class="math inline">\(x,y\)</span>之间不一定有偏序关系，所以取值为<span
class="math inline">\(0\)</span>的情况是others)</p>
<h2 id="möbius-变换">2. Möbius 变换</h2>
<p>我们定义对偏序集<span
class="math inline">\((P,\leq)\)</span>上的函数<span
class="math inline">\(f : P \rightarrow
\mathbb{C}\)</span>，Zeta变换的逆变换为莫比乌斯变换 <span
class="math inline">\(\mu : \mathcal{F}(P) \rightarrow
\mathcal{F}(P)\)</span>。<br />
有：<br />
<span class="math display">\[(\mu f)(x) = \sum_{y \leq x}\mu(y,x)
f(x)\]</span> 其中<span
class="math inline">\(\mu(y,x)\)</span>是对于偏序集上的莫比乌斯函数，这是一个二元函数，具体取值遵循以下的规律：<br />
<span class="math display">\[\sum_{y \leq z \leq x} \mu(y,z)\zeta(z,x) =
\delta(y,x)\]</span> 其中<span
class="math inline">\(\delta(y,x)\)</span>是克罗内克函数<br />
<span class="math display">\[\begin{align*}
\delta(x,y)=
\begin{cases}
1&amp;x = y\\
0&amp;x\neq y\\
\end{cases}
\end{align*}\]</span><br />
或者使用递归定义：<br />
<span class="math display">\[\mu(x,x) = 1 ,\\
\mu(y,x) = -\sum_{y\leq z &lt; x}\mu(y,z)\]</span></p>
<p>作为Zeta变换的逆变换，莫比乌斯变换有以下性质：<br />
<span class="math inline">\(\zeta\mu = \mu\zeta =
\operatorname{id}\)</span></p>
<h2 id="一些常见偏序集上的zeta-möbius-变换">3. 一些常见偏序集上的Zeta
&amp; Möbius 变换</h2>
<h3 id="a.-数论整除偏序-z">a. 数论，整除偏序 <span
class="math inline">\((Z^+,|)\)</span></h3>
<p>这里的Zeta变换对应与 <span class="math inline">\(I\)</span>
进行Dirichlet卷积，而Möbius变换则对应与<span
class="math inline">\(\mu\)</span>进行Dirichlet卷积，即数论函数的莫比乌斯反演.
<span class="math inline">\(\mu(y,x)\)</span>函数的取值:<br />
<span class="math display">\[\mu(d, n) = \mu(\frac{n}{d})\]</span><br />
右侧为数论中的莫比乌斯函数。<br />
如果我们想求解<span
class="math inline">\([1,n]\)</span>上zeta变换之后的函数，一个朴素的办法是对于每个数枚举他的倍数计入贡献，这个时间复杂度是<span
class="math inline">\(O(n\log n)\)</span>的。<br />
然而，我们可以加速这个过程。<br />
把每个不同的质因子看作单独的一维，实际上这就是在做一个高维前缀和。于是我们可以依次枚举每个质数，对每个质数枚举<span
class="math inline">\([2,\left\lfloor\frac{n}{p}\right\rfloor]\)</span>做前缀和。<br />
由于我们只枚举了质数位置的倍数，类似于埃氏筛法。我们可以得知这种做法的时间复杂度为<span
class="math inline">\(O(n\log\log n)\)</span>。<br />
这个操作一般成为Dirichlet前缀和。<br />
当然，在有限域<span
class="math inline">\([1,n]\)</span>上的整除关系上，我们可以对偶关系的Zeta变换，对应为Dirichlet后缀和，稍加变换枚举顺序即可。<br />
实际上，应该也可以枚举质数进行高维差分，实现<span
class="math inline">\(O(n\log\log n)\)</span>
求解莫反后的函数,这也就是快速莫比乌斯变换(FMT)在整除偏序上的运用。但是实际上由于我们基本上是对一个积性函数进行莫反，得到的函数仍然是积性函数，是可以线性筛出来的，不必这样加速，所以这种情况几乎不会遇到。</p>
<h3
id="b.幂集集合包含关系偏序-mathcalpssubseteq">b.幂集，集合包含关系偏序
<span class="math inline">\((\mathcal{P}(S),\subseteq)\)</span></h3>
<p>这里的 Zeta变换对应高维前缀和， 而Möbius变换则对应高维差分。<br />
Zeta变换的实现实际上就是我们所说的sosdp(逐维求前缀和),Möbius变换则是应该逐维差分的过程。<br />
有时候，我们可能要将包含关系逆过来，求解对偶关系上的zeta变换，那么就是把高维前缀和变成高维后缀和。
这一对变换在算法竞赛中一般被称为快速莫比乌斯变换(FWT)，用于解决一些位运算卷积的问题。<br />
实际上,这里的<span
class="math inline">\(\mu\)</span>函数取值是有规律可循的。有：<br />
<span class="math display">\[\mu(T,S) = (-1)^{|S|-|T|}\]</span><br />
证明：<br />
使用强数学归纳法。<br />
<span class="math inline">\(n = |S| - |T| =
0\)</span>时由定义显然成立。<br />
假设 <span class="math inline">\(|S| - |T| = k \leq n -
1\)</span>时成立<br />
<span class="math inline">\(|S| - |T| = n &gt; 0\)</span>时，<br />
<span class="math display">\[\begin{align*}
    \mu(T,S) &amp;= -\sum_{T\subseteq X \subsetneq S}\mu(T,X) \\
             &amp;= -\sum_{T\subseteq X \subsetneq S} (-1)^{|X| -
|T|}  &amp;归纳假设\\
             &amp;= -\sum_{0 \leq k\leq n-1} \binom{n}{k}
(-1)^k  &amp;枚举k = |X| - |T|\\
             &amp;= (-1)^n - \sum_{0 \leq k\leq n}\binom{n}{k} (-1)^k
\quad &amp;后半部分为0\\
             &amp;= (-1)^n\\
             &amp;= (-1)^{|S|-|T|}
\end{align*}\]</span> 归纳成立。<br />
于是<br />
<span class="math display">\[f(S) = \sum_{T \subseteq S}
(-1)^{|S|-|T|}(\zeta f)(T)\]</span> 这也正是集合上容斥定理的内容。</p>
<p>此外，如果我们定义odd-negation变换<span
class="math inline">\(\sigma\)</span>：<br />
<span class="math display">\[(\sigma f)(X) =
(-1)^{|X|}f(X)\]</span><br />
那么有：<br />
1. <span class="math inline">\(\sigma\sigma =
\operatorname{id}\)</span><br />
2. <span class="math inline">\(\mu = \sigma\zeta\sigma\)</span><br />
3. <span class="math inline">\(\zeta = \sigma\mu\sigma\)</span></p>
<p>也就是说Möbius变换我们也可以通过odd-negation变换和Zeta变换来实现。</p>
<h3 id="c.全序集-zleq">c.全序集 <span
class="math inline">\((Z^+,\leq)\)</span></h3>
<p>这里的zeta变换就是求前缀和了，而Möbius变换就是做差分。<br />
有:<br />
<span class="math display">\[\begin{align*}
\mu(y,x)=
\left\{
\begin{array}{ll}
1&amp;y=x\\
-1&amp;y = x - 1\\
0&amp; otherwise\\
\end{array}
\right.
\end{align*}\]</span></p>
<h2 id="更高视角的möbius变换">4.更高视角的Möbius变换</h2>
<p>对偏序集<span
class="math inline">\((P,\leq)\)</span>，定义关联代数<span
class="math inline">\(I(P)\)</span><br />
<span class="math display">\[I(P) = \mathcal{F}(P \times P) = \{
f：P\times P \rightarrow \mathbb{C} \mid f(x,y) = 0 ,\forall(x,y),x\nleq
y\}\]</span><br />
定义<span class="math inline">\(I(P)\)</span>上的卷积运算<span
class="math inline">\(*\)</span><br />
<span class="math display">\[(f*g)(x,y) = \sum_{x\leq z\leq
y}f(x,z)g(z,y)\]</span><br />
显然卷积运算满足结合律，存在单位元 <span
class="math inline">\(\delta\)</span> (克罗内克函数)。 于是 <span
class="math inline">\((I(P)，*)\)</span>构成一个幺半群。<br />
如果一个函数 <span class="math inline">\(f\)</span> 满足<span
class="math inline">\(f(x,x) \neq 0 ,\forall x \in P\)</span>，那么
<span class="math inline">\(f\)</span> 存在逆元 <span
class="math inline">\(g\)</span><br />
递归定义：<br />
<span class="math display">\[\begin{align*}
g(x,y)=
\left\{
\begin{array}{ll}
\frac{1}{f(y,y)}&amp;x=y\\
-\frac{1}{f(y,y)} \sum_{x\leq z&lt; y } g(x,z)f(z,y) &amp;x &lt; y\\
0&amp; otherwise\\
\end{array}
\right.
\end{align*}\]</span> 于是 <span class="math inline">\(g*f =
\delta\)</span>,而幺半群中左逆元即为逆元。<br />
对 <span class="math inline">\(\zeta\)</span> 函数，它的逆即为 <span
class="math inline">\(\mu\)</span>。<br />
我们将<span class="math inline">\(\mathrm{Z}\)</span>变换，<span
class="math inline">\(\mathrm{M}\)</span>变换(大写以示区分)看作定义在<span
class="math inline">\(\mathcal{F}(P)\)</span>上的线性算子(根据前面的推论，它满足线性空间的8条性质)，那么我们可以得出变换和关联代数的联系
：<br />
对 <span class="math inline">\(f\in \mathcal{F}(P)\)</span>, <span
class="math display">\[\mathrm{Z} (f) = \zeta * f, \quad \mathrm{M} (f)
= \mu * f\]</span><br />
而变换的复合对应卷积<br />
<span class="math display">\[(\mathrm{M}\mathrm{Z}) (f) =
\operatorname{id} (f) = \delta * f = \mu * \zeta * f\]</span></p>
一个有趣的事实是：对于关联代数中的某个二元函数，我们可以用一个矩阵来表示它。而它如果存在逆元，则是这个矩阵的逆矩阵对应的二元函数。而且前面我们讨论的存在逆元的条件如果从矩阵的角度分析就很容易理解了。<br />
下面是以整除关系为例展示一下上面的结论：<br />
整除关系<span class="math inline">\(\zeta\)</span>函数矩阵：<br />

<span class="math display">\[\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\]</span>
逆矩阵(<span class="math inline">\(\mu\)</span>函数矩阵)：<br />

<span class="math display">\[\begin{bmatrix}
1 &amp; -1 &amp; -1 &amp; 0 &amp; -1 &amp; 1\\
0 &amp; 1 &amp; 0 &amp; -1 &amp; 0 &amp; -1\\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; -1\\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\]</span>
<p>可以观察到逆矩阵的第一行正好是<span
class="math inline">\(\mu\)</span>的前6项，这和我们的推论是吻合的。</p>
<h1 id="part-3.inclusion-exclusion-on-posets">Part 3.Inclusion-Exclusion
on Posets</h1>
<p>前面我们已经通过莫比乌斯变换很自然地导出了集合上的容斥定理: <span
class="math display">\[f(S) = \sum_{T \subseteq S} (-1)^{|S|-|T|}(\zeta
f)(T)\]</span> 如这里 <span class="math inline">\(f\)</span>
可以作为某个集合的上的计数函数，<span class="math inline">\(g = \zeta
f\)</span>则是所有子集的计数和。<br />
有限集下也有补集形式：<br />
<span class="math display">\[\zeta f(S) = \sum_{S \subseteq T}
(-1)^{|S|-|T|}(f)(T)\]</span>
然而，我们知道容斥定理并非只有这一种形式，比如说还有最经典的集合交-集合并容斥，以及像Min-Max容斥和k-th容斥，二项式反演这种特殊的容斥，这些容斥可否也通过莫比乌斯变换的理论得出呢?<br />
答案是肯定的，只需要我们选择合适的偏序集和合适的函数就可以推导出来。</p>
<h2 id="交集-并集容斥">交集-并集容斥</h2>
<p>设<span class="math inline">\(S\)</span>是全集，<span
class="math inline">\(A_1,A_2,\dots,A_n \subseteq S\)</span>.<br />
对任意子集<span class="math inline">\(I \subseteq \{1,2,\dots,n\}
=[n]\)</span>,<br />
定义： 子集交函数<span class="math inline">\(g\)</span>,<br />
<span class="math display">\[g(I) = \left|\bigcap\limits_{i \in
I}A_i\right|\]</span> 特别地，<span class="math inline">\(g(\emptyset) =
|S|\)</span><br />
精确计数函数<span class="math inline">\(f\)</span>,<span
class="math inline">\(f(I)\)</span>表示恰好属于所有<span
class="math inline">\(A_i，i\in I\)</span>且不属于其他任何<span
class="math inline">\(A_j,j\notin I\)</span>的元素个数。<br />
特别地，<span class="math inline">\(f(\emptyset) = |S| -
\left|\bigcup\limits_{i \in I}A_i\right|\)</span><br />
于是有<span
class="math inline">\(\mathbf{Z}_n^+\)</span>上的Zeta变换：<br />
<span class="math display">\[g(I) = \sum_{J \supseteq
I}f(J)\]</span><br />
(注意2点，一个是这里是在枚举超集，一个是这里<span
class="math inline">\(f\)</span>函数的定义，建议画图来理解一下实际含义。感觉上相当于先取所属集合的交集，再减去所有其他集合，可以用涂色的方式理解。而且如果我们用Venn图表示，每个<span
class="math inline">\(f(I)\)</span>都表示Venn图中极小的一块。)<br />
于是可以得到莫比乌斯反演公式：<br />
<span class="math display">\[f(I) = \sum_{J\supseteq
I}(-1)^{|J|-|I|}g(J)\]</span><br />
代入<span class="math inline">\(I = \emptyset\)</span>有：<br />
<span class="math display">\[\begin{align*}
    \left|\bigcup\limits_{i \in [n]}A_i\right|
    &amp;= |S| - \sum_{J \supseteq \emptyset}(-1)^{|J|}g(J)\\
    &amp;= \sum_{J \subseteq [n],J \neq \emptyset} (-1)^{|J| + 1}g(J)\\
    &amp;= \sum_{k = 1}^n (-1)^{k+1}\sum_{|J| = k}g(J)\\
    &amp;= \sum_{k = 1}^n (-1)^{k+1}\sum_{|J| =
k}\left|\bigcap\limits_{i \in J}A_i\right|
\end{align*}\]</span> 由此,我们通过构造<span
class="math inline">\((\mathcal{P}([n]),\supseteq)\)</span>这一偏序集及子集交函数，精确计数函数两个函数，从莫比乌斯反演推导出了并集-交集容斥。<br />
对于其他的容斥，也可以尝试构造合适的偏序集和函数得出。</p>
<h1 id="part-4.部分例题">Part 4.部分例题</h1>
<p><del>这部分先鸽了之后再补</del></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>CF 3月部分题题解</title>
    <url>/2025/04/01/%E9%A2%98%E8%A7%A3/Codeforces/ProblemSet/2025Mar/</url>
    <content><![CDATA[<p><em>3月过完了再写3月的题解不是很正常吗</em></p>
<h1 id="cf2075f">1. <a
href="https://codeforces.com/problemset/problem/2075/F">CF2075F</a></h1>
<p>一道扫描线的题目。</p>
<h2 id="题意">题意</h2>
<p>定义好序列为序列左右两端分别为序列唯一最小值/最大值的序列，求给定数组中最长的好序列。<br />
数组长 <span class="math inline">\(n = 5\times 10^5\)</span>,值域 <span
class="math inline">\(a \leq 10^6\)</span>.</p>
<h2 id="分析">分析</h2>
<p>可以发现如果答案中一个数作为左端点，那么这个数左边一定没有小于等于它的数，否则我们我们选择左边小于等于它的数一定是更优的(有可能增加序列长度)。对于右端点同理，右边应该没有大于等于它的数。<br />
称这些左端点备选点/右端点备选点为左关键点/右关键点。我们可以用单调栈<span
class="math inline">\(O(n)\)</span>预处理出这些点。这些点的规模都可以达到<span
class="math inline">\(O(n)\)</span>。<br />
把数组元素的索引看成 <span class="math inline">\(x\)</span>,值看成 <span
class="math inline">\(y\)</span>,实际上我们要求的就是左关键点作为左下，右关键点作为右上的矩形内的点数(严谨一些来说这个矩阵要缩一圈)。<br />
于是很快可以想出来一个很暴力的<span class="math inline">\(O(n^2\log
V)\)</span>的算法：我们把左关键点和右关键点两两配对作为询问，用树状数组扫一遍离线处理(就是离线二维数点)。<br />
但是<span class="math inline">\(O(n^2\log
V)\)</span>显然不能通过该题，而任何一对关键点确实都有成为最终答案的可能，所以我们只能想办法一次处理多个点对了。<br />
我们可以考虑每次计算对于一个右关键点，所有左关键点的答案，取max。可以观察到对于一个点，它可以贡献到的左关键点是一个连续的区间，于是我们可以用一个线段树来维护每个左关键点的右上矩形内的点数。对于每个点的贡献区间<span
class="math inline">\([l,r]\)</span>可以<span class="math inline">\(O(n
\log n)\)</span>预处理出来。<br />
然后就是，我们要选一个顺序<span
class="math inline">\(O(n)\)</span>加入点的贡献，同时计算出所有右关键点处，所有左关键点处答案的max(这是一个区间max操作,还是线段树即可)。<br />
如果我们从右往左计算右关键点处的全局答案，那么用一个右关键点到下一个右关键点，矩形区域的右边界左移(删去超出边界的点)，上边界上移(加入应该加入的点)。于是我们可以想到一个加点的枚举方案：<br />
按 <span class="math inline">\(y\)</span> 从小到大加点，如果 <span
class="math inline">\(y\)</span> 相同则按 <span
class="math inline">\(x\)</span>
从大到小加点。如果遇到右关键点，先删去所有 <span
class="math inline">\(x\)</span>大于等于它的点的贡献，在统计一次答案。
按 <span class="math inline">\(x\)</span>
从大到小加点的原因是我们要在加入和关键点 <span
class="math inline">\(y\)</span>坐标相同的点之前统计答案(<span
class="math inline">\(x\)</span>大于关键点的点会被删，但是<span
class="math inline">\(x\)</span>小于关键点的点还可能作为别的关键点矩形内的点，所以换个顺序枚举肯定是错误的)。<br />
这个枚举顺序相当于两根扫描线，一根从下往上扫，一根从右往左扫，如果交点处是关键点就统计答案。<br />
于是我们得到了一个复杂度为<span class="math inline">\(O(n\log
n)\)</span>的算法。实现如下：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf = <span class="number">1145141919</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>, <span class="keyword">class</span> <span class="title class_">Tag</span>&gt; <span class="keyword">struct</span> <span class="title class_">LazySegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;Info&gt; info;</span><br><span class="line">    vector&lt;Tag&gt; tag;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_, v_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">LazySegmentTree</span><span class="params">(vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(init_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(<span class="built_in">vector</span>&lt;Info&gt;(n_, v_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">init</span><span class="params">(vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">        n = init_.<span class="built_in">size</span>();</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; (<span class="type">int</span>)<span class="built_in">log2</span>(n), <span class="built_in">Info</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; (<span class="type">int</span>)<span class="built_in">log2</span>(n), <span class="built_in">Tag</span>());</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = init_[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">            <span class="built_in">build</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[<span class="number">2</span> * p] + info[<span class="number">2</span> * p + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Tag&amp; v)</span> </span>&#123;</span><br><span class="line">        info[p].<span class="built_in">apply</span>(v);</span><br><span class="line">        tag[p].<span class="built_in">apply</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">apply</span>(<span class="number">2</span> * p, tag[p]);</span><br><span class="line">        <span class="built_in">apply</span>(<span class="number">2</span> * p + <span class="number">1</span>, tag[p]);</span><br><span class="line">        tag[p] = <span class="built_in">Tag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p, l, m, x, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p, l, m, x, y) + <span class="built_in">rangeQuery</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Tag&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">rangeApply</span>(<span class="number">2</span> * p, l, m, x, y, v);</span><br><span class="line">        <span class="built_in">rangeApply</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeApply</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">half</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (info[p].act == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((info[p].min + <span class="number">1</span>) / <span class="number">2</span> == (info[p].max + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, &#123; -(info[p].min + <span class="number">1</span>) / <span class="number">2</span> &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">half</span>(<span class="number">2</span> * p, l, m);</span><br><span class="line">        <span class="built_in">half</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">half</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">half</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F&amp;&amp; pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findFirst</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F&amp;&amp; pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findFirst</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F&amp;&amp; pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !<span class="built_in">pred</span>(info[p])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findLast</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findLast</span>(<span class="number">2</span> * p, l, m, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F&amp;&amp; pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findLast</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintainL</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (info[p].difl &gt; <span class="number">0</span> &amp;&amp; info[p].maxlowl &lt; pre) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p].max = info[p].maxlowl;</span><br><span class="line">            info[p].maxl = info[p].maxr = l;</span><br><span class="line">            info[p].maxlowl = info[p].maxlowr = -inf;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">maintainL</span>(<span class="number">2</span> * p, l, m, pre);</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, info[<span class="number">2</span> * p].max);</span><br><span class="line">        <span class="built_in">maintainL</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, pre);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintainL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maintainL</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintainR</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> suf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (info[p].difr &gt; <span class="number">0</span> &amp;&amp; info[p].maxlowr &lt; suf) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p].max = info[p].maxlowl;</span><br><span class="line">            info[p].maxl = info[p].maxr = l;</span><br><span class="line">            info[p].maxlowl = info[p].maxlowr = -inf;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="built_in">maintainR</span>(<span class="number">2</span> * p + <span class="number">1</span>, m, r, suf);</span><br><span class="line">        suf = <span class="built_in">max</span>(suf, info[<span class="number">2</span> * p + <span class="number">1</span>].max);</span><br><span class="line">        <span class="built_in">maintainR</span>(<span class="number">2</span> * p, l, m, suf);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maintainR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maintainR</span>(<span class="number">1</span>, <span class="number">0</span>, n, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> Tag&amp; t)</span>&amp; </span>&#123;</span><br><span class="line">        <span class="comment">//x = max(x, t.x);</span></span><br><span class="line">        x += t.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Tag</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Tag</span>(<span class="type">int</span> _x)</span><br><span class="line">        :<span class="built_in">x</span>(_x)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> Tag&amp; t)</span>&amp; </span>&#123;</span><br><span class="line">        x += t.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Info</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> _x)</span><br><span class="line">        :<span class="built_in">x</span>(_x)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Info <span class="keyword">operator</span>+(<span class="type">const</span> Info&amp; a, <span class="type">const</span> Info&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">max</span>(a.x, b.x) &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;pre, suf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.<span class="built_in">empty</span>() || a[i] &lt; a[pre.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">            pre.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suf.<span class="built_in">empty</span>() || a[i] &gt; a[suf.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">            suf.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = pre.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">preval</span>(m),<span class="built_in">rpreval</span>(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        preval[i] = a[pre[i]];</span><br><span class="line">        rpreval[i] = a[pre[m - <span class="number">1</span> - i]];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">issuf</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; suf.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        issuf[suf[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LazySegmentTree&lt;Info, Tag&gt;<span class="built_in">t</span>(m);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">l</span>(n<span class="number">+1</span>), <span class="built_in">r</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        l[i] = m -(<span class="built_in">lower_bound</span>(rpreval.<span class="built_in">begin</span>(), rpreval.<span class="built_in">end</span>(), a[i]) - rpreval.<span class="built_in">begin</span>()) ;</span><br><span class="line">        r[i] = <span class="built_in">upper_bound</span>(pre.<span class="built_in">begin</span>(), pre.<span class="built_in">end</span>(), i) - pre.<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">yid</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">iota</span>(yid.<span class="built_in">begin</span>(), yid.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(yid.<span class="built_in">begin</span>(), yid.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> i, <span class="type">int</span> j)-&gt;<span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[j])<span class="keyword">return</span> i &gt; j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[i] &lt; a[j];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt;pq;<span class="comment">//x</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> id = yid[i];</span><br><span class="line">        <span class="keyword">if</span> (l[id] &lt;= r[id]) &#123;</span><br><span class="line">            t.<span class="built_in">rangeApply</span>(l[id], r[id] + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            pq.<span class="built_in">push</span>(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (issuf[id]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>() &gt;= id) &#123;</span><br><span class="line">                <span class="type">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                t.<span class="built_in">rangeApply</span>(l[x], r[x] + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l[id] &lt;= r[id])</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, t.<span class="built_in">rangeQuery</span>(l[id], r[id] + <span class="number">1</span>).x + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="cf2021e">2. <a
href="https://codeforces.com/problemset/problem/2021/E3">CF2021E</a></h1>
<p>一道kruskal重构树+树形dp，但是E3需要利用凸性优化了。</p>
<h2 id="题意-1">题意</h2>
<p>一个图有<span class="math inline">\(n\)</span>个点，<span
class="math inline">\(m\)</span>条带权边，图上有<span
class="math inline">\(p\)</span>个关键点，求图上选取<span
class="math inline">\(k =
1,2,...,n\)</span>个点作为源点时，所有关键点到任一源点的最大瓶颈路的最小值之和的最小值。<br />
数据范围：E2 <span class="math inline">\(n,m,p \leq 5000\)</span> , E3
<span class="math inline">\(n,m,p \leq 2\times 10^5\)</span></p>
<h2 id="分析-1">分析</h2>
<h3 id="e2">E2</h3>
<p>先看E2.<br />
最大瓶颈路自然想到kruskal重构树算法。我们对图的最小生成树建成kruskal重构树，树上两个叶结点<span
class="math inline">\(u,v\)</span>的lca权值<span
class="math inline">\(val[lca(u,v)]\)</span>就是这两点的最小瓶颈路权值。<br />
接下来的问题是怎么去计算题目要求的东西。<br />
E2的数据范围足以让<span
class="math inline">\(O(n^2)\)</span>的算法通过，于是我们考虑做一个树形dp。
设置状态 <span class="math inline">\(dp[i][j]\)</span> 表示：子树<span
class="math inline">\(i\)</span>上选择<span
class="math inline">\(j\)</span>个点作为源点时，子树上关键点的计算值的最小和,<span
class="math inline">\(cnt[i]\)</span> 表示<span
class="math inline">\(i\)</span>子树的关键点个数。<br />
我们合并子树时，设<span class="math inline">\(u\)</span>是<span
class="math inline">\(l,r\)</span>的父节点(kruskal重构树是一颗二叉树)，有状态转移方程：</p>
<p><span class="math display">\[\begin{align}
    dp[u][i] &amp;= \min_{1\leq j\leq i-1}\{dp[l][j] + dp[r][i-j]\}\\
    dp[u][i] &amp;= \min\{cnt[l]*val[u] + dp[r][i]
,cnt[r]*val[u]+dp[l][i]\}\\
\end{align}\]</span></p>
<p><span
class="math inline">\((1)\)</span>式实际上就是左右子树都选有点，那么左右子树内的点就不会跨过父节点(权值更大)来走最小瓶颈路了，实际上就是直接相加。<br />
<span
class="math inline">\((2)\)</span>式描述如果一个子树内不选点，那么这个子树就要跨过父节点寻路，cost就是子树内关键点个数乘父节点(lca)权值了。<br />
然后我们就得到了这样一个dp。<br />
有人可能会问，这不是一眼<span
class="math inline">\(O(n^3)\)</span>?这能过<span
class="math inline">\(n= 5000\)</span>?<br />
还真能。<br />
实际上这是一个类似树上背包的过程，而树上背包使用了上下界优化后(dp转移几乎一致)的复杂度并非是<span
class="math inline">\(O(n^3)\)</span>，而是可以证明为是<span
class="math inline">\(O(nV)\)</span>的(<span
class="math inline">\(V\)</span>是容量限制)，证明概要是每个点对只在lca处被合并一次。所以这个dp的复杂度是<span
class="math inline">\(O(np)\)</span>，足以通过E2.<br />
代码实现如下：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;fa;</span><br><span class="line">    <span class="comment">//vector&lt;int&gt;sz;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        fa.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="comment">//sz.resize(n);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            <span class="comment">//sz[i] = 1;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[p] == p ? p : (fa[p] = <span class="built_in">find</span>(fa[p]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> fu = <span class="built_in">find</span>(u), fv = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (fu == fv) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//if (sz[fu] &lt; sz[fv]) &#123;</span></span><br><span class="line">            <span class="comment">//    swap(fu, fv);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//sz[fu] += sz[fv];</span></span><br><span class="line">            fa[fv] = fu;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> edge = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> Edge = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line">    <span class="type">int</span> n, m , k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;edge&gt;&gt;<span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line">    priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;&gt;&gt;pq;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(&#123; v,w &#125;);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(&#123; u,w &#125;);</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123; w,u,v &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">DSU <span class="title">dsu</span><span class="params">(n * <span class="number">2</span>)</span></span>;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">val</span>(n * <span class="number">2</span>);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">kruskal</span>(n * <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> id)-&gt;<span class="type">void</span></span><br><span class="line">        &#123;</span><br><span class="line">            dsu.<span class="built_in">merge</span>(id, u);</span><br><span class="line">            dsu.<span class="built_in">merge</span>(id, v);</span><br><span class="line">            kruskal[u].<span class="built_in">push_back</span>(id);</span><br><span class="line">            kruskal[v].<span class="built_in">push_back</span>(id);</span><br><span class="line">            kruskal[id].<span class="built_in">push_back</span>(u);</span><br><span class="line">            kruskal[id].<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">//kruskal</span></span><br><span class="line">    <span class="keyword">while</span> (id &lt; n) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [w, u, v] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (dsu.<span class="built_in">find</span>(u) != dsu.<span class="built_in">find</span>(v)) &#123;</span><br><span class="line">            val[n + id] = w;</span><br><span class="line">            <span class="type">int</span> a = dsu.<span class="built_in">find</span>(u), b = dsu.<span class="built_in">find</span>(v);</span><br><span class="line">            <span class="built_in">add</span>(a, b, n + id);</span><br><span class="line">            id++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt</span>(n * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : a) &#123;</span><br><span class="line">        cnt[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> ll inf = <span class="number">1e16</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> fa)-&gt;vector&lt;ll&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kruskal[p].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                vector&lt;ll&gt;<span class="built_in">dp</span>(<span class="number">2</span>);</span><br><span class="line">                dp[<span class="number">0</span>] = cnt[p] ? inf : <span class="number">0</span>;</span><br><span class="line">                dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> dp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                array&lt;vector&lt;ll&gt;, <span class="number">2</span>&gt;sdp;</span><br><span class="line">                array&lt;<span class="type">int</span>, 2&gt;sons;</span><br><span class="line">                <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> s : kruskal[p]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s != fa) &#123;</span><br><span class="line">                        sons[id] = s;</span><br><span class="line">                        sdp[id++] = <span class="built_in">self</span>(self, s, p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">auto</span>&amp; [l, r] = sdp;</span><br><span class="line">                <span class="keyword">auto</span>&amp; [L, R] = sons;</span><br><span class="line">                cnt[p] = cnt[L] + cnt[R];</span><br><span class="line">                vector&lt;ll&gt;<span class="built_in">dp</span>(l.<span class="built_in">size</span>() + r.<span class="built_in">size</span>() - <span class="number">1</span>, inf);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; l.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; r.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                        dp[i + j] = <span class="built_in">min</span>(dp[i + j], l[i] + r[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; l.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], l[i] + val[p] * cnt[R]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; r.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], r[j] + val[p] * cnt[L]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;&amp;dp = <span class="built_in">dfs</span>(dfs, n * <span class="number">2</span> - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; dp[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="e3">E3</h3>
<p>E3 的数据范围为<span class="math inline">\(2\times
10^5\)</span>,<span
class="math inline">\(O(np)\)</span>的算法显然无法通过了，我们只能去寻求<span
class="math inline">\(O(n\log n)\)</span>的做法。<br />
我们的求解的方法(树形dp)显然没办法被替换成别的办法了，但是dp的均摊转移时间是<span
class="math inline">\(O(p)\)</span>的，我们或许可以想办法优化dp转移。<br />
再观察dp转移式：</p>
<p><span class="math display">\[\begin{align*}
    dp[u][i] &amp;= \min_{1\leq j\leq i-1}\{dp[l][j] + dp[r][i-j]\}\\
    dp[u][i] &amp;= \min\{cnt[l]*val[u] + dp[r][i]
,cnt[r]*val[u]+dp[l][i]\}\\
\end{align*}\]</span></p>
<p>可以发现<span
class="math inline">\((1)\)</span>式是一个{min,+}卷积的形式，这或许是在提示我们往凸优化的方向去想。再想一想<span
class="math inline">\(dp[i]\)</span>这个函数，可以发现它的差分是单调递减的(非严格)，因为如果我们选取第<span
class="math inline">\(i\)</span>个点后减小<span
class="math inline">\(d_i\)</span>，选取第<span
class="math inline">\(i+1\)</span>个点后减小<span
class="math inline">\(d_{i+1}\)</span>,如果<span
class="math inline">\(d_i &lt;
d_{i+1}\)</span>，那么我们显然可以交换这两次选的点使得<span
class="math inline">\(d_i\)</span>更小，这是违背dp状态定义的。所以<span
class="math inline">\(dp[i]\)</span>是一个下凸的函数。<br />
现在我们知道了这个函数是下凸的，那么{min,+}卷积就可以用闵可夫斯基和做，实际上就是维护两个凸包的差分序列，贪心加入更大值。<br />
那么合并这个差分数组，我们就可得到<span
class="math inline">\(dp[i]\)</span>从<span
class="math inline">\(1\)</span>开始的向后差分，但是<span
class="math inline">\(0\)</span>对<span
class="math inline">\(1\)</span>的差分不太符合。<br />
我们合并两个凸包时，都加入了子树内<span class="math inline">\(dp[i][0] -
dp[i][1]\)</span>的值，但是这个值在向上转移时<span
class="math inline">\(dp[i][0]\)</span>的代价发生了变化。因此我们应该进行一些修改。<br />
考虑<span class="math inline">\(0\)</span>对<span
class="math inline">\(1\)</span>的差分，这对应的是不选其中一颗子树时的特殊转移。根据dp数组的定义，这是选择其中一颗子树的一个点时，最小的权值和。<br />
写出选择<span class="math inline">\(l\)</span>子树的差分值：</p>
<p><span class="math display">\[\begin{align*}
d_1(u)_l &amp;= cnt[p]*val[p] - (cnt[r] *val[p] + dp[l][1]) \\
       &amp;= (cnt[p] - cnt[r])*val[p] -(cnt[l]*val[l] - d_1(l)) \\
       &amp;= cnt[l]*(val[p]-val[l]) + d_1(l)
\end{align*}\]</span></p>
<p>选择<span class="math inline">\(r\)</span>子树的差分值类似。<br />
我们要做的就是把<span class="math inline">\(d_1(l)\)</span>和<span
class="math inline">\(d_1(r)\)</span>换成这个式子即可。<br />
当然也有难以理解一些的做法：<br />
可以发现这是仅和<span class="math inline">\(l\)</span>或<span
class="math inline">\(r\)</span>及其父亲相关的一个式子。<br />
那么我们其实可以直接在转移到父亲的时候就把这个式子换成父亲的式子(就是<span
class="math inline">\(d_1(p) \rightarrow
d_1(fa[p])_p\)</span>),特判一下根处不做这个操作即可。<br />
这样，我们就把一次转移优化到了<span
class="math inline">\(O(size(p))\)</span>,而对于这样的树上转移和合并，我们有强大的武器：树上启发式合并来维护差分序列的转移，这样整个转移我们可以实现到<span
class="math inline">\(O(n\log
n)\)</span>。如果我们使用multiset维护差分序列，最终的复杂度是<span
class="math inline">\(O(n^2\log n)\)</span>.<br />
得到差分序列，我们可以反向还原出<span class="math inline">\(k =
1,2,...n\)</span>的答案。<br />
实现如下：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//前面与E2保持一致    </span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt</span>(n * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : a) &#123;</span><br><span class="line">        cnt[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理启发式合并</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> root = n * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">hson</span>(n * <span class="number">2</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">lson</span>(n * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> get_hson = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> fa)-&gt;<span class="type">void</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> s : kruskal[p]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s != fa) &#123;</span><br><span class="line">                    <span class="built_in">self</span>(self, s, p);</span><br><span class="line">                    cnt[p] += cnt[s];</span><br><span class="line">                    <span class="keyword">if</span> (hson[p] == <span class="number">0</span> || cnt[hson[p]] &lt; cnt[s]) &#123;</span><br><span class="line">                        lson[p] = hson[p];<span class="comment">//don&#x27;t forget</span></span><br><span class="line">                        hson[p] = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        lson[p] = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="built_in">get_hson</span>(get_hson, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> ll inf = <span class="number">1e16</span> + <span class="number">10</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    multiset&lt;ll&gt;d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现1</span></span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> fa, multiset&lt;ll&gt;&amp; d)-&gt;<span class="type">void</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (kruskal[p].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[p]) &#123;</span><br><span class="line">                d.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            multiset&lt;ll&gt;r;</span><br><span class="line">            <span class="built_in">self</span>(self, hson[p], p, d);</span><br><span class="line">            <span class="built_in">self</span>(self, lson[p], p, r);</span><br><span class="line">            <span class="keyword">if</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = <span class="built_in">prev</span>(d.<span class="built_in">end</span>());</span><br><span class="line">                d.<span class="built_in">insert</span>((val[p] - val[hson[p]]) * cnt[hson[p]] + *x);</span><br><span class="line">                d.<span class="built_in">erase</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!r.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> iter = r.<span class="built_in">begin</span>(); <span class="built_in">next</span>(iter) != r.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">                    d.<span class="built_in">insert</span>(*iter);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">auto</span> y = <span class="built_in">prev</span>(r.<span class="built_in">end</span>());</span><br><span class="line">                d.<span class="built_in">insert</span>((val[p] - val[lson[p]]) * cnt[lson[p]] + *y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现2</span></span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> fa, multiset&lt;ll&gt;&amp;d)-&gt;<span class="type">void</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kruskal[p].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[p]) &#123;</span><br><span class="line">                    d.<span class="built_in">insert</span>(val[fa]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                multiset&lt;ll&gt;r;</span><br><span class="line">                <span class="built_in">self</span>(self, hson[p], p, d);</span><br><span class="line">                <span class="built_in">self</span>(self, lson[p], p, r);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : r) &#123;</span><br><span class="line">                    d.<span class="built_in">insert</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!d.<span class="built_in">empty</span>() &amp;&amp; p != root) &#123;<span class="comment">//modify dp[0]</span></span><br><span class="line">                    <span class="keyword">auto</span> x = <span class="built_in">prev</span>(d.<span class="built_in">end</span>());</span><br><span class="line">                    d.<span class="built_in">insert</span>(*x + (val[fa] - val[p]) * cnt[p]);</span><br><span class="line">                    d.<span class="built_in">erase</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(dfs, root, <span class="number">0</span>, d);</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">ans</span>(n + <span class="number">1</span>);</span><br><span class="line">    ans[<span class="number">0</span>] = val[root] * cnt[root];</span><br><span class="line">    id = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//从大到小遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> rit = d.<span class="built_in">rbegin</span>(); rit != d.<span class="built_in">rend</span>();rit++) &#123;</span><br><span class="line">        ans[id++] =  ans[id - <span class="number">1</span>] - *rit;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 然而，从哥哥那里学到了更好的写法 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> ll inf = <span class="number">1e16</span> + <span class="number">10</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    vector&lt;ll&gt;d;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> fa)-&gt;ll</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kruskal[p].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[p]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> val[fa];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ll vl = <span class="number">0</span>, vr = <span class="number">0</span>;</span><br><span class="line">                vl = <span class="built_in">self</span>(self, hson[p], p);</span><br><span class="line">                vr = <span class="built_in">self</span>(self, lson[p], p);</span><br><span class="line">                <span class="keyword">if</span> (vl &lt; vr)<span class="built_in">swap</span>(vl, vr);</span><br><span class="line">                d.<span class="built_in">push_back</span>(vr);</span><br><span class="line">                <span class="keyword">if</span> (p != root) &#123;<span class="comment">//modify dp[0]</span></span><br><span class="line">                    vl += ((val[fa] - val[p]) * cnt[p]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> vl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="built_in">dfs</span>(dfs, root, <span class="number">0</span>));<span class="comment">//jiangly 维护 max 的方法太优雅了</span></span><br><span class="line">    <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), greater&lt;&gt;());</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">ans</span>(n + <span class="number">1</span>);</span><br><span class="line">    ans[<span class="number">0</span>] = val[root] * cnt[root];</span><br><span class="line">    id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : d) &#123;</span><br><span class="line">        ans[id++] = ans[id - <span class="number">1</span>] - v;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
jiangly使用了类似实现2的维护差分序列的方式。<br />
由于我们只需要修改<span
class="math inline">\(d_1\)</span>,即差分序列最大值，其他值绝对不变，前面我们使用multiset加启发式合并是没有必要的。<br />
我们还是选择dfs，返回<span
class="math inline">\(d_1(fa[p])_p\)</span>,每个非叶节点接受两个返回值后，存入那个较小的,修改那个较大的为对应返回值(根节点除外)后返回。
这样的话，我们就无需在dfs过程中存储维护差分序列，而是每次将不再会修改的值加入全局的差分序列中即可。最后再排个序。时间复杂度为<span
class="math inline">\(O(n\log
n)\)</span>。(哥哥还是太强了!要多学习哥哥代码!)。</p>
<h1 id="cf2089b2">3. <a
href="https://codeforces.com/problemset/problem/2089/B2">CF2089B2</a></h1>
<p>很典的破链成环的题。<br />
<del><em>本来想写个破链成环的专题的，但是想着手上也就两三道就算了，在这里提一嘴得了</em></del></p>
<h2 id="题意-2">题意</h2>
<p>大致上<span class="math inline">\(a,b\)</span>两个数组，<span
class="math inline">\(\operatorname{sum}(a) \leq
\operatorname{sum}(b)\)</span>,<span
class="math inline">\(a\)</span>每次减去对应位置的<span
class="math inline">\(b\)</span>直到<span
class="math inline">\(a\)</span>等于<span
class="math inline">\(0\)</span>，操作完循环右移一位再次操作，问多少次操作可以把<span
class="math inline">\(a\)</span>全部置为0。<br />
B2的附加条件是可以初始对<span
class="math inline">\(a\)</span>任意位置元素进行最多<span
class="math inline">\(k\)</span>次递减操作。<br />
数据范围：数组长<span class="math inline">\(n \leq 2\times 10 ^
5\)</span></p>
<h2 id="分析-2">分析</h2>
<p>首先把链展开为<span
class="math inline">\(2n\)</span>的链，在链上滑动窗口一下，记录每个<span
class="math inline">\(a\)</span>的和小于等于<span
class="math inline">\(b\)</span>的和的子段长，最大值即为答案。<br />
这样B1就写完了。<br />
有一说一，一开始看到这个还以为要二分，后面发现直接求就可以。<br />
再说B2。<br />
B2被yzc在群里说什么优先队列维护位置什么的误导了，想不懂他是怎么维护的，搞得我以为B2很神秘，后面发现完全不用那样。<br />
对于k，我们直接二分答案即可。(没错，B1我想过的二分在这里回来了，我居然没想出来，QAQ).<br />
check的方法也不难，我们找到B1解法中，最长段的左端点<span
class="math inline">\(l\)</span>(如果有多个，选最左边那个)。可以证明这个左端点<span
class="math inline">\(l\)</span>小于等于<span
class="math inline">\(n\)</span>。<br />
然后我们再在<span
class="math inline">\([l,l+n)\)</span>这个区间上跑一个滑动窗口，每次加入<span
class="math inline">\(a\)</span>，用<span
class="math inline">\(b\)</span>一直减队尾的<span
class="math inline">\(a\)</span>，如果队首的<span
class="math inline">\(a\)</span>超出了我们check的轮数就用k次递减减去。而最后肯定消完了，不用考虑剩下的(这就是我们选择<span
class="math inline">\(l\)</span>作为区间左端点的理由)。<br />
代码实现：<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">a</span>(n*<span class="number">2</span>), <span class="built_in">b</span>(n*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        b[i + n] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    ll sa = <span class="number">0</span>, sb = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        sa += a[i];</span><br><span class="line">        sb += b[i];</span><br><span class="line">        len++;</span><br><span class="line">        <span class="keyword">if</span> (sa &lt;= sb) &#123;</span><br><span class="line">            sa = <span class="number">0</span>;</span><br><span class="line">            sb = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; ans) &#123;</span><br><span class="line">                l = i - len + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, len);</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> rounds) -&gt;<span class="type">bool</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll rem = k;</span><br><span class="line">            <span class="type">int</span> pa = l, pb = l;</span><br><span class="line">            deque&lt;pair&lt;<span class="type">int</span>,ll&gt;&gt;qa;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; l + n; i++) &#123;</span><br><span class="line">                qa.<span class="built_in">push_back</span>(&#123; i,a[i] &#125;);</span><br><span class="line">                <span class="keyword">if</span> (!qa.<span class="built_in">empty</span>() &amp;&amp; i - qa.<span class="built_in">front</span>().first == rounds) &#123;</span><br><span class="line">                    rem -= qa.<span class="built_in">front</span>().second;</span><br><span class="line">                    qa.<span class="built_in">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                ll x = b[i];</span><br><span class="line">                <span class="keyword">while</span> (!qa.<span class="built_in">empty</span>() &amp;&amp; x != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; qa.<span class="built_in">back</span>().second) &#123;</span><br><span class="line">                        qa.<span class="built_in">back</span>().second -= x;</span><br><span class="line">                        x = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        x -= qa.<span class="built_in">back</span>().second;</span><br><span class="line">                        qa.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rem &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> L = <span class="number">-1</span>, R = ans;</span><br><span class="line">    <span class="keyword">while</span> (R - L &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> m = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(m)) &#123;</span><br><span class="line">            R = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            L = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; R &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="cf2085f2">4. <a
href="https://codeforces.com/problemset/problem/2085/F2">CF2085F2</a></h1>
<p>带点思维的题，一开始没想到用初始状态和最终状态确定贡献的算法，想了一下午一晚上。</p>
<h2 id="题意-3">题意</h2>
<p>定义好数组为长为<span class="math inline">\(k\)</span>且<span
class="math inline">\(1 \sim
k\)</span>均出现一次的数组。给一个长度为<span
class="math inline">\(n\)</span>的数组<span
class="math inline">\(a\)</span>，只能相邻两两交换，问最少操作多少次使得有一个子数组是好数组。保证<span
class="math inline">\(a\)</span>中<span class="math inline">\(1\sim
k\)</span>至少出现一次。<br />
数据范围：F1 <span class="math inline">\(k\leq n\leq 3000\)</span>, F2
<span class="math inline">\(k \leq n\leq 4\times 10^5\)</span></p>
<h2 id="分析-3">分析</h2>
<p>F1允许<span class="math inline">\(O(n^2 \log
n)\)</span>通过，F2则至少要<span class="math inline">\(O(n \log
n)\)</span>.<br />
先想想我们移动的策略：我们假设最终组成好数组的是一些元素，那么最优操作是把两边的元素往中间的元素交换靠拢。<br />
假设中间元素的位置是 <span class="math inline">\(x\)</span>，<span
class="math inline">\(l = \left\lfloor\frac{k}{2}\right\rfloor, r =
\left\lceil\frac{k}{2}\right\rceil\)</span>，选中元素的初始位置是<span
class="math inline">\(pos(i)\)</span><br />
那么可以用操作花费可以用一个公式描述<br />
<span class="math display">\[cost(x) = \sum_{i = 1}^k \left| x -
pos(i)\right| - \frac{l(l+1)}{2} - \frac{r(r+1)}{2}\]</span>
(对于一些位置，这个公式的计算结果是不对的，因为不能均匀从两边靠拢。但是我们可以证明中间位置的计算结果永远会比这些不正确的结果不劣，所以没影响)<br />
我们可以对于每个位置<span
class="math inline">\(x\)</span>，遍历一遍数组，计算每个位置的值并放到对应元素值处，每个元素值取最小结果，最后计算这个式子即可得到答案。
计算这个式子的时间复杂度为<span
class="math inline">\(O(n)\)</span>,所以我们得到了一个<span
class="math inline">\(O(n^2)\)</span>的F1做法。</p>
<p>对于F2,对每个位置重新计算一次<span
class="math inline">\(cost\)</span>显然没有利用好上一次计算的信息。<br />
我们先对<span
class="math inline">\(k\)</span>个值的每个值单独考虑，可以把每个元素的贡献写成一张<span
class="math inline">\(n \times k\)</span>的数表。<br />
示例：</p>
<p>实际上cost就是不同值的cost的叠加。<br />
可以观察到同一值相邻的cost只有3种变化<span
class="math inline">\(\{-1,0,1\}\)</span>,那么我们使用差分来研究它们的性质，这里取向前差分<br />
设<span class="math inline">\(d_1(i) = cost(i) -
cost(i-1)\)</span>，我们抽出上面例子中的值<span
class="math inline">\(1\)</span>来研究，无关值用<span
class="math inline">\(0\)</span>代替</p>
<p>可以观察到，<span
class="math inline">\(d_2\)</span>在每个值出现位置加一处取2(一阶差分从-1跳变到1)，同时两个相同值的中间两个位置加一处各减一。<br />
根据这个规律，我们<span class="math inline">\(O(n)\)</span>预处理出<span
class="math inline">\(d_2\)</span>,再还原出<span
class="math inline">\(d_1,cost\)</span>，再遍历<span
class="math inline">\(cost\)</span>取得最大答案即可。<br />
最后时间复杂度为<span class="math inline">\(O(n)\)</span>，很神奇。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>ProblemSet</category>
      </categories>
  </entry>
  <entry>
    <title>CF 2月部分题题解</title>
    <url>/2025/02/02/%E9%A2%98%E8%A7%A3/Codeforces/ProblemSet/2025Feb/</url>
    <content><![CDATA[<h1 id="cf-近期题解">CF 近期题解</h1>
<p><em>鸽了好久，感觉还是多谢题解会更有提高</em></p>
<h2 id="d"><a
href="https://codeforces.com/contest/2056/problem/D">2056D</a></h2>
<p>算法： 偏序，枚举，二值化(中位数的常见方法)， 前缀和</p>
<h3 id="题意">题意</h3>
<p>求给定数组的所有子数组中，前中位数和后中位数相等的子数组的数量。数组值域<span
class="math inline">\(\Omega\)</span>为<span class="math inline">\(1
\sim 10\)</span>。数组长<span class="math inline">\(10^5\)</span>。</p>
<h3 id="分析">分析</h3>
<p>由于值域很小，可以枚举中位数，将小于中位数的数赋值为<span
class="math inline">\(-1\)</span>，大于的赋值为<span
class="math inline">\(1\)</span>。<br />
考虑某个区间小于,等于，大于所枚举的中位数的分别有<span
class="math inline">\(l,m,r\)</span>个，合法区间满足约束条件：<br />
<span class="math display">\[\begin{cases}
    l + m &gt; r \\
    r + m &gt; l \\
\end{cases}\]</span></p>
<h4 id="方法一正向统计">方法一：正向统计</h4>
<p>由此我们得到了合法区间满足的两个偏序关系：<br />
对区间<span class="math inline">\([1,i]\)</span>,令$ f_i = l + m - r ,
g_i = r + m - l$<br />
对合法区间<span
class="math inline">\([l,r]\)</span>(l,r含义与前文不同，这里是区间端点)有偏序关系<br />
<span class="math display">\[\begin{cases}
    f_{l-1} &lt; f_{r} \\
    g_{l-1} &lt; g_{r} \\
\end{cases}\]</span><br />
于是我们事先计算好<span
class="math inline">\(f,g\)</span>数组，跑一个二维偏序即可。要注意的是这里的偏序是严格偏序，相等不能计入数量。<br />
二维偏序可以树状数组/分治实现。<br />
复杂度是<span class="math inline">\(O(\Omega n\log n)\)</span><br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bit</span> <span class="comment">//1 base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> upper;</span><br><span class="line">    vector&lt;T&gt;tree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bit</span>(vector&lt;T&gt; a)</span><br><span class="line">    &#123;</span><br><span class="line">        n = a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        tree = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="built_in">lowbit</span>(i) &lt;= n) &#123;</span><br><span class="line">                tree[i + <span class="built_in">lowbit</span>(i)] += tree[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        upper = n;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lowbit</span>(upper) != upper) &#123;</span><br><span class="line">            <span class="keyword">while</span> (upper != <span class="built_in">lowbit</span>(upper)) &#123;</span><br><span class="line">                upper -= <span class="built_in">lowbit</span>(upper);</span><br><span class="line">            &#125;</span><br><span class="line">            upper &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">            tree[p] += x;</span><br><span class="line">            p += <span class="built_in">lowbit</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">qry</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">            res += tree[r];</span><br><span class="line">            r -= <span class="built_in">lowbit</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">qry</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">qry</span>(r) - <span class="built_in">qry</span>(l - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">qry</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findleq</span><span class="params">(T v)</span><span class="type">const</span> <span class="comment">//前缀和小于等于的最大位置</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        T sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = upper; len != <span class="number">0</span>; len &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len + p &lt;= n &amp;&amp; sum + tree[len + p] &lt;= v) &#123;</span><br><span class="line">                p += len;</span><br><span class="line">                sum += tree[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findl</span><span class="params">(T v)</span><span class="type">const</span> <span class="comment">//严格小的最大位置</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = upper;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        T sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = upper; len != <span class="number">0</span>; len &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len + p &lt;= n &amp;&amp; sum + tree[len + p] &lt; v) &#123;</span><br><span class="line">                p += len;</span><br><span class="line">                sum += tree[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span><span class="comment">//</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            tree[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">10</span>; k++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">le</span>(n + <span class="number">1</span>), <span class="built_in">re</span>(n + <span class="number">1</span>);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;<span class="built_in">pr</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= k) &#123;</span><br><span class="line">                le[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                le[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= k) &#123;</span><br><span class="line">                re[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                re[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">            le[i] += le[i - <span class="number">1</span>];</span><br><span class="line">            re[i] += re[i - <span class="number">1</span>];</span><br><span class="line">            pr[i] = &#123; le[i],re[i] &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(pr.<span class="built_in">begin</span>(), pr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;<span class="comment">//往右平移一段，去掉负值</span></span><br><span class="line">            le[i] = pr[i].first + n + <span class="number">1</span>;</span><br><span class="line">            re[i] = pr[i].second + n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bit&lt;<span class="type">int</span>&gt;<span class="built_in">t</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * n + <span class="number">10</span>));</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">        <span class="type">int</span> p = le[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (le[i] &gt; p) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    t.<span class="built_in">add</span>(s.<span class="built_in">top</span>(), <span class="number">1</span>);</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                p = le[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ans += t.<span class="built_in">qry</span>(re[i] - <span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">push</span>(re[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="方法二逆向统计">方法二：逆向统计</h4>
<p>我们可以考虑统计非法区间的数量，再用所有区间数量减去非法的得到合法的区间数量。<br />
考虑<strong>非法区间的性质：一定存在一个数<span
class="math inline">\(x\)</span>,使得区间中小于等于<span
class="math inline">\(x\)</span>的数和大于<span
class="math inline">\(x\)</span>的数数量相等</strong>。<br />
那么我们可以用正向一样的前缀和方法来计算。<br />
枚举数<span class="math inline">\(x\)</span>，小于等于<span
class="math inline">\(x\)</span>的赋值为-1，大于<span
class="math inline">\(x\)</span>的赋值为1，设<span
class="math inline">\(f\)</span>为前缀和数组。那么非法区间<span
class="math inline">\([l,r]\)</span>有:<br />
<span class="math display">\[f[r] = f[l - 1]\]</span><br />
具体做法是开一个数组<span class="math inline">\(cnt\)</span>来统计<span
class="math inline">\(f\)</span>的值为<span
class="math inline">\(k\)</span>时,满足的数量。<br />
然而，形如<span
class="math inline">\([1,1,4,5,1,4]\)</span>的区间，在<span
class="math inline">\(x =
1,2,3\)</span>时都会计入一次非法区间，会导致重复计数。重复计数后好像没有什么办法通过容斥减去重复，那么有没有办法避免重复呢?<br />
一些非法区间有很多个<span
class="math inline">\(x\)</span>可以check到，但是<strong>这些<span
class="math inline">\(x\)</span>中只有最小的那个会在这个区间中出现！</strong>(可以check到的一定是连续的一些，下界一定出现在非法区间中)<br />
那么我们计数的时候，只在<span
class="math inline">\(x\)</span>最小时计入数量，或者说只在<span
class="math inline">\(x\)</span>出现在这个区间时，我们才计入这个非法区间的贡献。<br />
那么我们怎么确保我们统计的区间里面有<span
class="math inline">\(x\)</span>呢？回想我们前面的方法是对当前点<span
class="math inline">\(r\)</span>,把<span
class="math inline">\(cnt[f_r]\)</span>作为以<span
class="math inline">\(r\)</span>为右端点的非法区间的数量。这里小于<span
class="math inline">\(r\)</span>的点都已经计入了<span
class="math inline">\(cnt\)</span>中。那么如果我们要求区间一定含有<span
class="math inline">\(x\)</span>,那么在更改后的方法里，<span
class="math inline">\(r\)</span>到已经加入<span
class="math inline">\(cnt\)</span>的点之间必须有一个<span
class="math inline">\(x\)</span>。<br />
所以我们一个考虑一个点何时加入到<span
class="math inline">\(cnt\)</span>中：从它本身开始(<strong>不包括本身</strong>)(因为作为左端点<span
class="math inline">\(l\)</span>时，表示的区间是从<span
class="math inline">\(l+1\)</span>开始的),直到遇到一个<span
class="math inline">\(x\)</span>，我们再把他加入到<span
class="math inline">\(cnt\)</span>中，那么对于所有的<span
class="math inline">\(r\)</span>,我们在求解它时加入<span
class="math inline">\(cnt\)</span>的点至少和<span
class="math inline">\(r\)</span>之间有一个<span
class="math inline">\(x\)</span>。<br />
而对于每个点，如果是<span
class="math inline">\(x\)</span>的话，我们应该先加入应该加入的点，再计算。<br />
如果用数组统计的话，算法是线性的，时间复杂度为<span
class="math inline">\(O(\Omega n)\)</span><br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = n*(n<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ps</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= i) </span><br><span class="line">                ps[j]++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                ps[j]--;</span><br><span class="line">            ps[j] += ps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="type">int</span>, ll&gt;mp;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;buf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] == i) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!buf.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    mp[buf.<span class="built_in">top</span>()]++;</span><br><span class="line">                    buf.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans -= mp[ps[j]];</span><br><span class="line">            buf.<span class="built_in">push</span>(ps[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="d-1"><a
href="https://codeforces.com/contest/2057/problem/D">2057D</a></h2>
<p>算法：偏序，线段树</p>
<h3 id="题意-1">题意</h3>
<p>给一个数组。单点修改<span
class="math inline">\(q\)</span>次，每次求最大的
子数组极差减去子区间长度的值。<br />
<span class="math inline">\(n,q = 10^5\)</span></p>
<h3 id="分析-1">分析</h3>
<p>首先，子数组极差只取决于最大值或者最小值，那么如果答案取决于某个子数组，那么这个子数组的两端一定为最大值或者最小值，否则我们可以缩短这个子数组而不影响极差，使得答案变大。<br />
这里我们就可以形式化地写出答案的形式：<br />
<span class="math display">\[ans = \max {(|a_r-a_l| - (r -
l))}\]</span><br />
但这还是很棘手，因为答案的两部分是分开的，没有联系起来。<br />
很多时候，我们要求数组上一个某一个表达式的最值，都应该把这个表达式转化成只与某个点/区间端点单独决定的表达式，如某个点上的前缀和/差分/下标/点值以及它们的组合等等，而且在表达式中我们最好把与某个点相关的表达式放在一起组成一个整体。<br />
如果我们确定一下<span class="math inline">\(a_r\)</span>和<span
class="math inline">\(a_l\)</span>的大小关系，就可以去掉这个绝对值：<br />
<span class="math display">\[ans =
\begin{cases}
    (a_r - r) - (a_l - l) &amp; a_r \leq a_l \\
    (a_l + l) - (a_r + r) &amp; a_r \geq a_l \\
\end{cases}\]</span> 定义<span class="math inline">\(f_i = a_i - i,g_i =
a_i + i\)</span><br />
这样，我们就可以把问题转化为找区间<span
class="math inline">\([l,r]\)</span>，使得<span
class="math inline">\(f_r - f_l、 g_l- g_r\)</span>最大。<br />
直接暴力找是不行的，我们注意到一个区间只能有一个最小值和最大值，那么我们可以用一个分治算法来求解。对于<span
class="math inline">\(f\)</span>，算法的大概流程是：<br />
1. 递归地求解左右子区间的最值和答案<br />
2. 用右子区间<span
class="math inline">\(f\)</span>的最大值减去左子区间<span
class="math inline">\(f\)</span>的最小值作为答案，与左右子区间的答案取<span
class="math inline">\(\max\)</span>作为该区间的答案。</p>
<p>对于<span class="math inline">\(g\)</span>的算法是类似的。<br />
这个算法的复杂度是<span class="math inline">\(O(n\log
n)\)</span>。<br />
但是我们还需要进行<span
class="math inline">\(q\)</span>次单点修改，求解的均摊时间不能超过<span
class="math inline">\(O(\log n)\)</span><br />
观察到每次修改单点，对于我们的分治算法，最多只有<span
class="math inline">\(\log
n\)</span>个区间受到影响。这很像线段树的单点修改，而实际上我们的分治算法完全可以用一个线段树来实现，而单点修改就写一个线段树的单点修改就行。对于<span
class="math inline">\(f,g\)</span>，我们分别建两颗线段树即可(也可以一颗)。<br />
最终的算法时间复杂度为<span class="math inline">\(O(n\log
n)\)</span>。<br />
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">segtree</span> <span class="comment">//单点修改，区间查询max,min,以</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt;a;</span><br><span class="line">    vector&lt;T&gt;tmax;</span><br><span class="line">    vector&lt;T&gt;tmin;</span><br><span class="line">    vector&lt;T&gt;ans1;</span><br><span class="line">    vector&lt;T&gt;ans2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">segtree</span>(vector&lt;<span class="type">int</span>&gt;&amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        n = a.<span class="built_in">size</span>();</span><br><span class="line">        tmax.<span class="built_in">resize</span>(n * <span class="number">4</span> + <span class="number">1</span>);</span><br><span class="line">        tmin.<span class="built_in">resize</span>(n * <span class="number">4</span> + <span class="number">1</span>);</span><br><span class="line">        ans<span class="number">1.</span><span class="built_in">resize</span>(n * <span class="number">4</span> + <span class="number">1</span>);</span><br><span class="line">        ans<span class="number">2.</span><span class="built_in">resize</span>(n * <span class="number">4</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tmax[p] = <span class="built_in">max</span>(tmax[p * <span class="number">2</span>], tmax[p * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        tmin[p] = <span class="built_in">min</span>(tmin[p * <span class="number">2</span>], tmin[p * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        ans1[p] = <span class="built_in">max</span>(tmax[p * <span class="number">2</span> + <span class="number">1</span>] - tmin[p * <span class="number">2</span>], <span class="built_in">max</span>(ans1[p * <span class="number">2</span>], ans1[p * <span class="number">2</span> + <span class="number">1</span>]));</span><br><span class="line">        ans2[p] = <span class="built_in">max</span>(tmax[p * <span class="number">2</span>] - tmin[p * <span class="number">2</span> + <span class="number">1</span>], <span class="built_in">max</span>(ans2[p * <span class="number">2</span>], ans2[p * <span class="number">2</span> + <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tmax[p] = tmin[p] = a[l];</span><br><span class="line">            ans1[p] = ans2[p] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(l, m, p * <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(m + <span class="number">1</span>, r, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> s, T val, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tmax[p] = tmin[p] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= m) &#123;</span><br><span class="line">            <span class="built_in">update</span>(s, val, l, m, p * <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">pushup</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">update</span>(s, val, m + <span class="number">1</span>, r, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">pushup</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">get_ans1</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get_ans2</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">update</span>(p, val, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">mima</span>(n), <span class="built_in">mami</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        mima[i] = a[i] - i;</span><br><span class="line">        mami[i] = a[i] + i;</span><br><span class="line">    &#125;</span><br><span class="line">    segtree&lt;<span class="type">int</span>&gt;<span class="built_in">t1</span>(mima), <span class="built_in">t2</span>(mami);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(t<span class="number">1.</span><span class="built_in">get_ans1</span>(), t<span class="number">2.</span><span class="built_in">get_ans2</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> p, x;</span><br><span class="line">        cin &gt;&gt; p &gt;&gt; x;</span><br><span class="line">        p--;</span><br><span class="line">        t<span class="number">1.</span><span class="built_in">modify</span>(p, x - p);</span><br><span class="line">        t<span class="number">2.</span><span class="built_in">modify</span>(p, x + p);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(t<span class="number">1.</span><span class="built_in">get_ans1</span>(), t<span class="number">2.</span><span class="built_in">get_ans2</span>()) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="未完待续咕咕咕">未完待续咕咕咕</h2>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>ProblemSet</category>
      </categories>
  </entry>
  <entry>
    <title>2023.5.29</title>
    <url>/2025/05/29/%E7%94%9F%E6%B4%BB/%E9%9A%8F%E7%AC%94/2023.5.29/</url>
    <content><![CDATA[<p>写于2025.5.29下午，考计组之前。标题日期是故意的。</p>
<p>不知道为什么并不是很想复习计组，有一种莫名的自毁倾向？(说是自毁也不合适，我只是真的对加权厌倦了)<br />
于是开始在b站上闲逛，意外地刷了一连串方舟的视频(主要是各种EP),把我拉回到那个2023年的夏天。<br />
《Before
Summer》,23年方舟写给高考考生的歌。老高考只有2天，所以考新高考的我在第二天下午回家的时候就听到了这首歌。当时我的手机电池是坏的，只能插线使用(好像是拔掉充电线30s内关机吧)。我是回当时租在高中旁的房子拿第三天要考的生物和化学资料，很难得地没有像平日上学时一样急急忙忙地，只是坐在床边拿起手机插上耳机，在高考还没有结束的第二天下午听完了属于我那一年的歌，然后拿起资料去了学校。当时其实并没有太多的感想，唯一记得比较清楚的可能是有一种“一切真的都要结束了”的预感吧。考完后更多的也是陷入一种狂欢，失落，好奇等等感觉的叠加态中，并没有多去回味这首歌了。现在看来这首歌的词真的很好，对那个夏天的印象也大抵如是。虽然我对那个夏天的音乐印象可能和另外一首歌相关(《青い春と西の空》)<br />
《青い春と西の空》,是结束乐队的歌。这首歌我从高考前就开始听了。当时的感想其实忘了很多，可能听这首也主要是因为这是结束乐队的歌？(高考前最有共感的一首应该是《小さな海》)这首歌给我最深的印象是在高考后的一天去同学家住了一晚，次日独自返回一个人住的房子时，停车驻足在桥上眺望远处的孝感东站，当时耳机里放的刚好就是这一首。考完后的自由与兴奋，对未来和远方的好奇和渴望都在那一刻被清楚地被刻印下来成为我这首歌的音乐记忆。而我也意识到或许与歌名一样，我高中的青春真的结束了，该骑上我的车去往下一站了。<br />
《Misty
Memory》,方舟23年的夏活曲。印象最深的应该是办升学宴的那一天(8.1)，正好也是夏活开启的那一天。升学宴结束后和X同学在车上聊了很多：有一些关于《孤星》的讨论和一些其他的话题(我已经忘得差不多了)。当时正好一起欣赏了一下这首夏活的主界面曲。下车后还一起聊了一会升学宴的事情，其实我也感觉我做的确实不够好(详细的也不说了),或许这也是我希望转变自己，让自己更加成熟可靠一些的一个开始吧。正如夏活剧情，我度过了一个梦幻的而又有些许悲伤的粉红色的夏天，我也将去新的阶段迎来自己的成长。</p>
<p>将音乐与一个记忆片段联系起来，聆听音乐便是在阅读记忆。</p>
<p>突然回忆起高中或者说考后的那个夏天可能也并非偶然，前段时间与高中同学T见面就聊了很多这个话题。</p>
<p>对当下的生活和状态我的确有很多不满，我可能也得去做一些选择了。<br />
现在的我也和当时很不一样了。就连写随笔，当时的我有一个小笔记本记一下各种各样的事情，而现在的第一反应居然已经是打开vscode在blog目录里面写markdown了。现在的我其实也是想要弥补一些高中的缺憾，但是自己是否在各个方面有进步真的不好说。但无论如何都还是应该不断调整自己，朝着自己真正热爱的方向一直走下去。</p>
<p>2023年是我印象最深的一年，就连平时打日期也偶尔会误写成2023。<br />
偶尔抒发一下对过去的情感。无论选择的前路如何，该继续前进了。</p>
<p>2025.5.29 16:12</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>幽灵乐团式子推导</title>
    <url>/2025/06/07/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/exMusic/</url>
    <content><![CDATA[<h1 id="幽灵乐团">幽灵乐团</h1>
<p>写一下幽灵乐团的式子推导过程</p>
<h2 id="题目及式子">题目及式子</h2>
<p>求解 <span
class="math display">\[\prod_{i=1}^A\prod_{j=1}^B\prod_{k=1}^C
\frac{\operatorname{lcm}(i,j)}{\gcd(i,k)}^{f(type)} \bmod P, type =
0,1,2\]</span> 其中 <span class="math inline">\(f(0) = 1, f(1) =
ijk,f(2) = \gcd(i,j,k)\)</span> <span class="math inline">\(1 \leq A,B,C
\leq 10^5, P\in \{prime\}, 10^7 \leq P \leq 1.05 \times 10^9\)</span>
后面推导式子过程中会使用一些中间公式进行替换，并且省略求和/求积符号下的"=1"</p>
<h2 id="基本变换">基本变换</h2>
<p><span class="math display">\[\begin{align*}
    &amp;\prod_i^A\prod_j^B\prod_k^C
\frac{\operatorname{lcm}(i,j)}{\gcd(i,k)}^{f(type)}\\
    &amp;=\prod_i^A\prod_j^B\prod_k^C
\frac{ij}{\gcd(i,k)\gcd(i,k)}^{f(type)}\\
    &amp;=\frac
    {
    \prod_i^A\prod_j^B\prod_k^C i^{f(type)}\times       
    \prod_i^A\prod_j^B\prod_k^C j^{f(type)}
    }
    {
    \prod_i^A\prod_j^B\prod_k^C gcd(i,j)^{f(type)} \times
    \prod_i^A\prod_j^B\prod_k^C gcd(i,k)^{f(type)}
    }\\
    &amp;=\frac
    {
        F_1(A,B,C) \times F_1(B,A,C)
    }
    {
        F_2(A,B,C) \times F_2(A,C,B)
    }
\end{align*}\]</span></p>
<p>其中： <span class="math display">\[F_1(A,B,C) =
\prod_i^A\prod_j^B\prod_k^C i^{f(type)}\]</span> <span
class="math display">\[F_2(A,B,C) = \prod_i^A\prod_j^B\prod_k^C
gcd(i,j)^{f(type)}\]</span> 于是我们可以把原式拆开成两个独立的部分<span
class="math inline">\(F_1,F_2\)</span>计算。 下面来依次推理<span
class="math inline">\(type = 0,1,2\)</span>时的式子。 用<span
class="math inline">\(N\)</span> 表示<span
class="math inline">\(A,B,C\)</span>的<span
class="math inline">\(\min\)</span>，可能是一部分。</p>
<h2 id="type-0"><span class="math inline">\(type = 0\)</span></h2>
<p>最简单的</p>
<p><span class="math display">\[\begin{align*}
    F_1(A,B,C)
    &amp;=\prod_i^A\prod_j^B\prod_k^C i\\
    &amp;= {i!}^{BC}
\end{align*}\]</span></p>
<p><span class="math display">\[\begin{align*}
    F_2(A,B,C)  
    &amp;=  \prod_i^A\prod_j^B\prod_k^C \gcd(i,j) \\
    &amp;=  \prod_i^A\prod_j^B \gcd(i,j)^{C} \\
    &amp;=  \prod_d^N d^{\sum_i^A \sum_j^B [\gcd(i,j) = d] \times C}
&amp;\text{(枚举gcd)}\\
    &amp;= \prod_d^N d^{\sum\limits_x^{\lfloor\frac{N}{d}\rfloor} \mu(x)
\lfloor\frac{A}{dx}\rfloor \lfloor\frac{B}{dx}\rfloor \times C}
&amp;\text{(莫反)}\\
    &amp;= \prod_T^N (\prod_{d | T} d^{\mu(\frac{T}{d})})^{
\lfloor\frac{A}{dx}\rfloor \lfloor\frac{B}{dx}\rfloor \times C}
&amp;\text{(枚举 $T = dx$)}\\
    &amp;= \prod_T^N M_0(T)^{ \lfloor\frac{A}{dx}\rfloor
\lfloor\frac{B}{dx}\rfloor \times C}
\end{align*}\]</span></p>
<p>其中<span
class="math inline">\(M_0\)</span>可以预处理，一种方法是<span
class="math inline">\(O(n\log
n)\)</span>枚举因子计算贡献，还有一种是<span class="math inline">\(O(n
\log\log n)\)</span>类似狄利克雷前缀和去做，不过理解起来有些困难。
处理出<span
class="math inline">\(M_0\)</span>后，每次询问直接整除分块即可，单次时间复杂度<span
class="math inline">\(O(\sqrt n \log n)\)</span></p>
<h2 id="type-1"><span class="math inline">\(type = 1\)</span></h2>
<p>令 <span class="math inline">\(S_1(x) = \frac{x(x +
1)}{2}\)</span></p>
<p><span class="math display">\[\begin{align*}
    F_1(A,B,C)
    &amp;=\prod_i^A\prod_j^B\prod_k^C i^{ijk}\\
    &amp;= (\prod_i i^i)^{\sum_1^B j \times \sum_1^C k}\\
    &amp;= (\prod_i i^i)^{S_1(B) S_1(C)}
\end{align*}\]</span></p>
<p>预处理<span class="math inline">\(i^i\)</span>前缀积即可<span
class="math inline">\(O(\log n)\)</span>计算</p>
<p><span class="math display">\[\begin{align*}
    F_2(A,B,C)
    &amp;= \prod_i^A\prod_j^B\prod_k^C\gcd(i,j)^{ijk}\\
    &amp;= (\prod_i^A\prod_j^B \gcd(i,j)^{ij})^{S_1(C)}
\end{align*}\]</span></p>
<p>把里面的式子拿出来：</p>
<p><span class="math display">\[\begin{align*}
    &amp; \prod_i^A\prod_j^B \gcd(i,j)^{ij}\\
    &amp;= \prod_d^N d ^{\sum_i^A \sum_j^B [gcd(i,j)=d] \times ij}\\
    &amp;= \prod_d^N d^{d^2
    \sum\limits_i^{\lfloor\frac{A}{d}\rfloor}
    \sum\limits_j^{\lfloor\frac{B}{d}\rfloor}
    [gcd(i,j) = 1] \times (ij)
    } \text{(把因子$d$提出来)}\\
    &amp;= \prod_d^N d^{d^2
    \sum\limits_i^{\lfloor\frac{A}{d}\rfloor}
    \sum\limits_j^{\lfloor\frac{B}{d}\rfloor}
    (ij) \sum\limits_{x|i,x|j} \mu(x)
    }\text{(莫反)}\\
    &amp;= \prod_d^N d^{d^2
    \sum\limits_x^{\lfloor\frac{N}{d}\rfloor} \mu(x)
    \sum\limits_{x | i} i
    \sum\limits_{x | j} j
    }\text{(把$x$提到前面，后面准备变形)}\\
    &amp;= \prod_d^N d^{d^2
    \sum\limits_x^{\lfloor\frac{N}{d}\rfloor} \mu(x)
    xS_1(\lfloor\frac{A}{dx}\rfloor)
    xS_1(\lfloor\frac{B}{dx}\rfloor)
    } \text{(计算求和式，提出因子)}\\
    &amp;= \prod_d^N d^{
    \sum\limits_x^{\lfloor\frac{N}{d}\rfloor}(dx)^2 \mu(x)
    \times
    S_1(\lfloor\frac{A}{dx}\rfloor)
    S_1(\lfloor\frac{B}{dx}\rfloor)
    }\text{(整理一下)}\\
    &amp;= \prod_T^N \left((\prod_{d|T} d^{\mu(\frac{T}{d})})^{T^2}
\right) ^
    {S_1(\lfloor\frac{A}{T}\rfloor)
    S_1(\lfloor\frac{B}{T}\rfloor)} \text{(枚举$T = dx$)}\\
    &amp;= \prod_T^N \left(M_2(T) \right) ^
    {S_1(\lfloor\frac{A}{T}\rfloor)
    S_1(\lfloor\frac{B}{T}\rfloor)}
\end{align*}\]</span></p>
<p><span class="math inline">\(M_2(T) = M_0(T)
^{T^2}\)</span>,在前面<span
class="math inline">\(M_0\)</span>的基础上预处理<span
class="math inline">\(M_2\)</span>,同样整除分块计算即可做到<span
class="math inline">\(O(\sqrt n \log n)\)</span>的单次复杂度。</p>
<h2 id="type-2"><span class="math inline">\(type = 2\)</span></h2>
<p><em>这部分是看题解才会的</em></p>
<p><span class="math display">\[\begin{align*}
    &amp;F_1(A,B,C) \\
    &amp;= \prod_i^A\prod_j^B\prod_k^C i^{\gcd(i,j,k)}\\
    &amp;= \prod_i^A i ^{\sum_j^B \sum_k^C \gcd(i,j,k)} \\
    &amp;= \prod_i^A i ^{\sum_j^B \sum_k^C \sum_{\gcd(j,k)|i}\gcd(j,k) }
\text{(换种写法，把$i$分出来方便枚举gcd)}\\
    &amp;= \prod_i^A i ^{\sum_j^B \sum_k^C (\sum\limits_{x|i,x | j,x|k}
\phi(x))} \text{(经典转化$\mathrm{id} = \phi * I$)}\\
    &amp;= \prod_i^A i ^{\sum\limits_{x | i}\phi(x)
\lfloor\frac{B}{x}\rfloor \lfloor\frac{C}{x}\rfloor} \text{(改为枚举gcd
= $x$)}\\
    &amp;=\prod_x^N (\prod_{x|i}  i) ^{\phi(x)\lfloor\frac{B}{x}\rfloor
\lfloor\frac{C}{x}\rfloor} \text{(把$x$放在外面)}\\
    &amp;=\prod_x^N (x^{\lfloor\frac{A}{x}\rfloor}
(\lfloor\frac{A}{x}\rfloor!)) ^{\phi(x)\lfloor\frac{B}{x}\rfloor
\lfloor\frac{C}{x}\rfloor} \text{(计算里面的乘积)}\\
    &amp;= \prod_x^N
    (x ^{\phi(x)})
    ^{
        \lfloor\frac{A}{x}\rfloor \lfloor\frac{B}{x}\rfloor
\lfloor\frac{C}{x}\rfloor
    }
    \times
    \prod_x^N (\lfloor\frac{A}{x}\rfloor!)
^{\phi(x)\lfloor\frac{B}{x}\rfloor \lfloor\frac{C}{x}\rfloor}
\end{align*}\]</span></p>
<p>预处理<span class="math inline">\(x^{\phi(x)}\)</span>的前缀积和<span
class="math inline">\(\phi(x)\)</span>的前缀和(注意对<span
class="math inline">\(\phi(P) = P -
1\)</span>取模)即可通过整除分块计算。时间复杂度<span
class="math inline">\(O(\sqrt n\log n)\)</span></p>
<p>最折磨的还是下面这个式子</p>
<p><span class="math display">\[\begin{align*}
    &amp;F_2(A,B,C)\\
    &amp;= \prod_i^A\prod_j^B\prod_k^C \gcd(i,j)^{\gcd(i,j,k)}\\
    &amp;= \prod_d^N d^{\sum_i^A\sum_j^B [\gcd(i,j) = d] \times \sum_k^C
\gcd(d,k) }\text{(枚举gcd)}\\
    &amp;= \prod_d^N d^{\sum\limits_x^{\lfloor\frac{N}{d} \rfloor}
\mu(x) \lfloor\frac{A}{dx}\rfloor \lfloor\frac{B}{dx}\rfloor \times
\sum\limits_{e|d} \phi(e)
\lfloor\frac{C}{e}\rfloor}  \text{(对两部分莫反)}\\
    &amp;= \prod_d^N d^{\sum\limits_x^{\lfloor\frac{N}{d} \rfloor}
\mu(x) \lfloor\frac{A}{dx}\rfloor \lfloor\frac{B}{dx}\rfloor G(C,d)}
\text{(简记)}\\
    &amp;= \prod_T^N (\prod_{d | T} d ^ {\mu(\frac{T}{d}) \times
\sum\limits_{x|d} \phi(x) \lfloor\frac{C}{x}\rfloor})
^{\lfloor\frac{A}{T}\rfloor \lfloor\frac{B}{T}\rfloor}
    \text{(这里$x$已经不一样了)}
\end{align*}\]</span>\</p>
<p>上面我们的步骤都是枚举<span class="math inline">\(T = dx\)</span>,把
<span class="math inline">\(T\)</span>
相关部分放到最外面，预处理内部依赖于<span
class="math inline">\(T\)</span>的部分求解，但是<span
class="math inline">\(G(C,d)\)</span>还依赖于<span
class="math inline">\(C\)</span>,这使得我们无法对不同的<span
class="math inline">\(C\)</span>预处理，必须想办法寻求别的方法求解。
通过学习题解，这里又一个阴间小技巧，就是把<span
class="math inline">\(d\)</span>拆成<span class="math inline">\(d =
x\cdot \frac{x}{d}\)</span>,再继续化简成可以预处理方便求解的形式。</p>
<h3 id="x部分"><span class="math inline">\(x\)</span>部分</h3>
<p><span class="math display">\[\begin{align*}
    &amp; \prod_T^N (\prod_{d | T} x ^ {\mu(\frac{T}{d}) \times
\sum\limits_{x|d} \phi(x) \lfloor\frac{C}{x}\rfloor})
^{\lfloor\frac{A}{T}\rfloor \lfloor\frac{B}{T}\rfloor} \\
    &amp;=\prod_T^N (\prod_{d | T} \prod_{x | d} x ^ {\mu(\frac{T}{d})
\phi(x) \lfloor\frac{C}{x}\rfloor}) ^{\lfloor\frac{A}{T}\rfloor
\lfloor\frac{B}{T}\rfloor} \\
    &amp;=\prod_x^N \prod_T^{\lfloor\frac{N}{x}\rfloor}
    (\prod_{d|T} x ^{\mu(\frac{T}{d})\phi(x)\lfloor\frac{C}{x}\rfloor})
    ^{\lfloor\frac{A}{xT}\rfloor
\lfloor\frac{B}{xT}\rfloor}\text{(把$x$放到前面)}\\
    &amp;=\prod_x^N \prod_T^{\lfloor\frac{N}{x}\rfloor}
    \prod_{d|T} x ^{\mu(\frac{T}{d})\phi(x)\lfloor\frac{A}{xT}\rfloor
\lfloor\frac{B}{xT}\rfloor\lfloor\frac{C}{x}\rfloor}\\
    &amp;=\prod_x^N \prod_T^{\lfloor\frac{N}{x}\rfloor}
    x
^{(\sum\limits_{d|T}\mu(\frac{T}{d}))\phi(x)\lfloor\frac{A}{xT}\rfloor
\lfloor\frac{B}{xT}\rfloor\lfloor\frac{C}{x}\rfloor}\text{(莫反魔术的前奏)}\\
    &amp;=\prod_x^N \prod_T^{\lfloor\frac{N}{x}\rfloor}
    x ^{[T = 1]\phi(x)\lfloor\frac{A}{xT}\rfloor
\lfloor\frac{B}{xT}\rfloor\lfloor\frac{C}{x}\rfloor} \text{($\mu * 1 =
\epsilon$)}\\
    &amp;=\prod_x^N
    x ^{\phi(x)\lfloor\frac{A}{x}\rfloor
\lfloor\frac{B}{x}\rfloor\lfloor\frac{C}{x}\rfloor} \\
\end{align*}\]</span>\</p>
<p>这部分我们在前面已经求过</p>
<h3 id="fracdx部分"><span
class="math inline">\(\frac{d}{x}\)</span>部分</h3>
<p><span class="math display">\[\begin{align*}
    &amp;\prod_T^N (\prod_{d | T} (\frac{d}{x}) ^ {\mu(\frac{T}{d})
\times \sum\limits_{x|d} \phi(x) \lfloor\frac{C}{x}\rfloor})
^{\lfloor\frac{A}{T}\rfloor \lfloor\frac{B}{T}\rfloor} \\
    &amp;=\prod_x^N \prod_T^{\lfloor\frac{N}{x}\rfloor}
    (\prod_{d|xT,x|d} (\frac{d}{x})
^{\mu(\frac{xT}{d})\phi(x)\lfloor\frac{C}{x}\rfloor})
    ^{\lfloor\frac{A}{xT}\rfloor
\lfloor\frac{B}{xT}\rfloor}\text{(原来的$T$被换成$\frac{T}{x}$)}\\
    &amp;=\prod_x^N \prod_T^{\lfloor\frac{N}{x}\rfloor}
    (\prod_{d|xT} (\frac{d}{x}) ^{\mu(\frac{xT}{d})})
    ^{\lfloor\frac{A}{xT}\rfloor \lfloor\frac{B}{xT}\rfloor
\phi(x)\lfloor\frac{C}{x}\rfloor} \\
    &amp;= \prod_x^N \prod_T^{\lfloor\frac{N}{x}\rfloor}
    (\prod_{e|T} e ^{\mu(\frac{T}{e})})
    ^{\lfloor\frac{A}{xT}\rfloor \lfloor\frac{B}{xT}\rfloor
\phi(x)\lfloor\frac{C}{x}\rfloor} \text{(替换$e = \frac{d}{x}$)}\\
    &amp;= \prod_x^N \left(\prod_T^{\lfloor\frac{N}{x}\rfloor}
    (M_0(T))
    ^{\lfloor\frac{\lfloor\frac{A}{x}\rfloor}{T}\rfloor
\lfloor\frac{\lfloor\frac{B}{x}\rfloor}{T}\rfloor}
    \right)^{\phi(x)\lfloor\frac{C}{x}\rfloor} \text{(分一下块)}\\
\end{align*}\]</span></p>
<p>通过变换，我们得到了一个两层分块的结构。预处理<span
class="math inline">\(M_0\)</span>和<span
class="math inline">\(\phi(x)\)</span>的前缀和后，单次求解时间复杂度是<span
class="math inline">\(O(n^{0.75}\log
n)\)</span>，不过也可以通过预处理合适值域内部式子的值，做到<span
class="math inline">\(O(n^{\frac{2}{3}}\log n)\)</span>.</p>
<p>这样我们就把这题给做完了。 需要注意的一些点： 1. <span
class="math inline">\(\phi\)</span>前缀和和指数上的计算取模<span
class="math inline">\(\phi(P)-1\)</span>. 2. 预处理<span
class="math inline">\(M_0\)</span>,<span
class="math inline">\(\phi\)</span>的前缀积等函数的逆元，否则常数会变得较大，不好通过该题。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
  </entry>
</search>
